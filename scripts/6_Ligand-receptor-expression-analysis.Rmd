---
title: "6: Ligand-receptor expression analysis"
author: "James Choi"
date: "Last compiled on: `r Sys.Date()`"
output:
  html_document
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.align='center', 
                      tidy.opts=list(width.cutoff=80), tidy=TRUE)
```


```{r libraries}
library('SingleCellExperiment')
library('Seurat')
library('circlize')
library('ggplot2')
library('dplyr')
```


```{r directories}
results_out <- './results/6_Ligand-receptor-expression-analysis/'
dir.create(path = results_out)
remove_anno <- theme(panel.background = element_rect(color = NA, fill = NA),
                     panel.border = element_rect(color = NA, fill = NA),
                     panel.grid = element_blank(),
                     axis.title = element_blank(),
                     axis.text = element_blank(),
                     axis.ticks = element_blank(),
                     legend.title = element_blank(),
                     legend.key = element_blank(),
                     legend.background = element_blank())
```

```{r import_data}
svz <- readRDS(file = './data/svz.rds')
lr_ref <- read.csv(file = './ref/fantom_PairsLigRec_mouse.csv')
```


```{r LR_functions}
setupLR <- function(
  seurat_object,
  ref_path = NULL,
  lr_ref = NULL,
  split_by = NULL,
  min_pct = 0.1,
  assay = "RNA",
  slot = "data"
) {
  
  # Make sure seurat data is present
  if (class(seurat_object) != 'Seurat') {
    stop('\"seurat_object\" must be of class Seurat')
  }
  
  if (is.null(ref_path) && is.null(lr_ref)) {
    stop('Must provide either \"ref_path\" (path of LR reference) or \"lr_ref\" (data.frame of imported LR reference).')
  }
  
  # Load reference csv.
  if (!is.null(ref_path)) {
    lr_ref <- read.csv(file = ref_path, stringsAsFactors = FALSE)
  }
  
  # Set assay slot to be used.
  if (!assay %in% names(slot(seurat_object, 'assays'))) {
    stop('Provided assay not present in seurat_object.')
  } else {
    DefaultAssay(seurat_object) <- assay
  }
  
  # Check for Pair.Name column. Error if not present.
  if (!any(colnames(lr_ref) == 'Pair.Name')) {
    stop('Ligand-receptor reference list requires a column titled \"Pair.Name\".
         Entries in \"Pair.Name\" should be formatted as: [Ligand gene]_[Receptor gene]. 
         E.g. Apoe_Lrp1"')
  } else {
    pair_column <- which(colnames(lr_ref) == 'Pair.Name')
  }
  
  # Split Pair.Name into ligand and receptor names
  tmp <- strsplit(x = lr_ref[['Pair.Name']], split = '_')
  ligand_names <- sapply(X = tmp, FUN = `[`, 1)
  receptor_names <- sapply(X = tmp, FUN = `[`, 2)
  
  # Retain all ligand-receptor pairs where both gene names are present in the gene expression dataset
  all_genes <- rownames(slot(object = seurat_object[[assay]], 'counts'))
  lr_ref <- lr_ref[ligand_names %in% all_genes & receptor_names %in% all_genes,]
  if (nrow(lr_ref) == 0) {
    stop('No LR pairs were detected in provided Seurat data.')
  }
  
  # Get ligands and receptors that were detected in data
  tmp <- strsplit(x = lr_ref[['Pair.Name']], split = '_')
  ligand_names <- sapply(X = tmp, FUN = `[`, 1)
  receptor_names <- sapply(X = tmp, FUN = `[`, 2)
  
  # Analysis uses Seurat active identities. 
  # Message regarding use of Seurat identities
  if (any(grepl(pattern = '_', x = seurat_object@active.ident))) {
    stop('Active identity names cannot contain underscore "_". Please replace.')
  }
  tmp <- paste0('Using active identities: ', paste(unique(seurat_object@active.ident), collapse = ', '))
  message(tmp)
  
  # New vector of all genes to retrieve data
  retrieve_genes <- union(ligand_names, receptor_names)
  active_idents <- slot(object = seurat_object, name = 'active.ident')
  
  # Extract data
  lr_data <- FetchData(object = seurat_object, vars = c(split_by, retrieve_genes), slot = slot)
  active_idents <- slot(object = seurat_object, name = 'active.ident')
  lr_data <- cbind(active_idents, lr_data)
  
  # Calculate average/percent expression for each gene, by "split_by" if provided.
  exp_avg <- lr_data %>% group_by(active_idents, .add = TRUE)
  exp_pct <- lr_data %>% group_by(active_idents, .add = TRUE)
  if (!is.null(split_by)) {
    split_by_name <- as.name(split_by)
    exp_avg <- exp_avg %>% group_by(!!split_by_name, .add = TRUE)
    exp_pct <- exp_pct %>% group_by(!!split_by_name, .add = TRUE)
  }
  exp_avg <- exp_avg %>% summarise(across(where(is.numeric), .fns = mean))
  exp_pct <- exp_pct %>% summarise(across(where(is.numeric), .fns = function(x) round(mean(x > 0), 3)))
  
  # Determine which genes meet minimum percent detection threshold
  minpct_genes <- sapply(X = exp_pct[sapply(exp_pct, is.numeric)], FUN = function(x) any(x > 0))
  minpct_genes <- names(minpct_genes)[minpct_genes]
  lr_ref_out <- lr_ref[ligand_names %in% minpct_genes & receptor_names %in% minpct_genes,]
  lr_genes_out <- sort(unique(minpct_genes))
  
  # Table of cell counts, further split if "split_by" provided.
  if (!is.null(split_by)) {
    cell_counts <- table(slot(object = seurat_object, name = 'active.ident'),
                         slot(object = seurat_object, name = 'meta.data')[[split_by]])
  } else {
    cell_counts <- table(slot(object = seurat_object, name = 'active.ident'))
  }
  
  outs <- list(
    lr_data = lr_data,
    lr_ref = lr_ref_out,
    lr_genes = lr_genes_out,
    exp_avg = exp_avg,
    exp_pct = exp_pct,
    cell_counts = cell_counts,
    split_by = split_by,
    assay = assay,
    slot = slot
  )
  
  return(outs)
}
calculateLR <- function(
  setup,
  resample = 1000,
  adjust_pval = FALSE
) {
  # Import data
  lr_data <- setup[['lr_data']]
  lr_ref <- setup[['lr_ref']]
  lr_genes <- setup[['lr_genes']]
  exp_avg <- setup[['exp_avg']]
  exp_pct <- setup[['exp_pct']]
  split_by <- setup[['split_by']]
  cell_counts <- setup[['cell_counts']]
  assay <- setup[['assay']]
  slot <- setup[['slot']]
  
  # Cell-level expression matrix for genes in LR reference
  exp_mat <- as.matrix(lr_data[sapply(lr_data, is.numeric)])
  
  # Extract ligand/receptor gene names + expression matrices
  tmp <- strsplit(x = lr_ref[['Pair.Name']], split = '_')
  ligand_names <- sapply(X = tmp, FUN = `[`, 1)
  receptor_names <- sapply(X = tmp, FUN = `[`, 2)
  exp_mat_ligands <- exp_mat[,match(ligand_names, colnames(exp_mat))]
  exp_mat_receptors <- exp_mat[,match(receptor_names, colnames(exp_mat))]
  
  # Data.frame with results and null distribution score values
  if (class(lr_data[['active_idents']]) != 'factor') {
    stop('Seurat identities must be of class factor.')
  }
  if (!is.null(split_by)) {
    var_set <- expand.grid(levels(lr_data[['active_idents']]), 
                           levels(lr_data[['active_idents']]), 
                           unique(lr_data[[split_by]]))
    colnames(var_set) <- c('Ligand_cell', 'Receptor_cell', 'split_by')
  } else {
    var_set <- expand.grid(levels(lr_data[['active_idents']]), 
                           levels(lr_data[['active_idents']]))
    colnames(var_set) <- c('Ligand_cell', 'Receptor_cell')
  }
  
  # null_scores <- vector(mode = 'list', length = nrow(var_set))
  # names(null_scores) <- apply(X = var_set, MARGIN = 1, FUN = paste, collapse = '_')
  
  # Use maxT method for multiple hypotheses p-value adjustment 
  # (Benjamini-Hochberg appears too hard for 1000x permutations)
  if (adjust_pval) {
    maxT_scores <- matrix(0, nrow = resample, ncol = nrow(lr_ref))
    colnames(maxT_scores) <- paste(colnames(exp_mat_ligands), colnames(exp_mat_receptors), sep = '_')
  }
  
  # Calculate average expression matrix
  exp_names <- exp_avg[['active_idents']]
  if (!is.null(split_by)) {
    exp_names <- paste(exp_names, exp_avg[[split_by]], sep = '_')
  }
  
  # Get indices from expression matrix for ligands/receptors
  index_x <- var_set[['Ligand_cell']]
  index_y <- var_set[['Receptor_cell']]
  if (!is.null(split_by)) {
    index_x <- paste(index_x, var_set[['split_by']], sep = '_')
    index_y <- paste(index_y, var_set[['split_by']], sep = '_')
  }
  index_x <- match(x = index_x, table = exp_names)
  index_y <- match(x = index_y, table = exp_names)
  index_l <- match(ligand_names, colnames(exp_avg))
  index_r <- match(receptor_names, colnames(exp_avg))
  exp_avg_lig <- as.matrix(exp_avg[index_x, index_l])
  exp_avg_rec <- as.matrix(exp_avg[index_y, index_r])
  
  # # Sanity check - do all column LR pairs match for null maxT matrix and actual expression matrix?
  # sanity_check <- all(paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_') == colnames(tmp_scores))
  # if (!sanity_check) {
  #   stop('LR column indexing error: null score LR column names do not match sample score LR column names. Refer to source code. Sorry!')
  # }
  
  # Calculate LR scores (for data, not nulls)
  exp_scores <- 1/2 * (exp_avg_lig + exp_avg_rec)
  
  # NOTE: Percent threshold step is removed here and left to the visualization step for removal of data points.
  # # Determine which cells do not have at least 10% expression of their gene
  # exp_pct_l <- exp_pct[index_x, index_l] < 0.1
  # exp_pct_r <- exp_pct[index_y, index_r] < 0.1
  # exp_pct_lr <- exp_pct_l | exp_pct_r
  
  # Replace values that don't meet 10% threshold
  # exp_scores[exp_pct_lr] <- NA
  rownames(exp_scores) <- apply(X = var_set, MARGIN = 1, FUN = paste, collapse = '_')
  colnames(exp_scores) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')
  
  # Calculate p-values from ecdf using null scores for each LR-pair. 
  # NOTE: A true permutation test will test all possible permutations of cell-
  # sampling. Since this is computational impractical, we estimate with 1000 
  # permutations. Thus if LR-scores ("effects") are large, then p-values can be 
  # zero.  
  message('\nCalculating p-values...')
  pvals <- matrix(NA, nrow = nrow(var_set), ncol = ncol(exp_scores))
  colnames(pvals) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')
  rownames(pvals) <- apply(X = var_set, MARGIN = 1, FUN = paste, collapse = '_')
  
  # progress bar
  pb = txtProgressBar(min = 0, max = nrow(var_set), initial = 0, style = 3)
  
  # calculate null distribution of randomly permuted ligand-receptor score values
  for(i in 1:nrow(var_set)) {
    gc()
    cellx <- as.character(var_set[['Ligand_cell']][i]) # these are factors, but cell_counts is sorted by level
    celly <- as.character(var_set[['Receptor_cell']][i])
    if (!is.null(split_by)) {
      split_byz <- as.character(var_set[['split_by']][i])
      countx <- cell_counts[cellx, split_byz]
      county <- cell_counts[celly, split_byz]
    } else {
      countx <- cell_counts[cellx]
      county <- cell_counts[celly]
    }
    if (countx == 0 | county == 0) {
      next()
    }
    
    # Util function to randomly select n_c cells (n = #, c = cell-type) and extract element positions.
    cell_sample <- function(x, y) {
      tmp <- rep(0, nrow(exp_mat))
      tmp[sample(nrow(exp_mat), size = x + y, replace = FALSE)] <- 1
      tmp[tmp == 1][sample(x + y, size = y, replace = FALSE)] <- 2
      return(tmp)
    }
    null_index <- t(replicate(n = resample, 
                              expr = cell_sample(x = countx, y = county)))
    null_index_x <- null_index == 1
    null_index_y <- null_index == 2
    
    # Calculate average expression of all ligands and receptors for the n_c cells
    null_avg_lig <- (null_index_x %*% exp_mat_ligands) / countx
    null_avg_rec <- (null_index_y %*% exp_mat_receptors) / county
    
    # Calculate null LR scores
    null_scores <- 1/2 * (null_avg_lig + null_avg_rec)
    colnames(null_scores) <- paste(colnames(null_avg_lig), colnames(null_avg_rec), sep = '_')
    
    # For max-T method, take element-wise maximum values (this iterates nrow(var_set) times)
    # null_scores[[i]] <- tmp_nulls
    if (adjust_pval) {
      maxT_scores[null_scores > maxT_scores] <- null_scores[null_scores > maxT_scores]
    }
    
    # Calculate p-value with ecdf()
    for (j in 1:length(exp_scores[i,])) {
      pvals[i,j] <- 1-ecdf(null_scores[,j])(exp_scores[i,][j])
    }
    
    # progress bar
    setTxtProgressBar(pb, i)
  }
  
  
  # For adjusted p-values:
  if (adjust_pval) {
    adj_pvals <- matrix(1, nrow = nrow(var_set), ncol = nrow(lr_ref))
    colnames(adj_pvals) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')
    rownames(adj_pvals) <- apply(X = var_set, MARGIN = 1, FUN = paste, collapse = '_')
    
    for(j in 1:ncol(adj_pvals)) {
      adj_pvals[,j] <- sapply(X = exp_scores[,j],
                              nulls = maxT_scores[,j],
                              FUN = function(x, nulls) {1-ecdf(nulls)(x)})
    }
  }
  
  
  # Long-form data.table of results
  tmp <- expand.grid(rownames(exp_scores), colnames(exp_scores), stringsAsFactors = FALSE)
  tmp_idents <- strsplit(x = tmp[[1]], split = '_')
  tmp_pairs <- strsplit(x = tmp[[2]], split = '_')
  ligand_cell <- sapply(X = tmp_idents, FUN = `[[`, 1)
  receptor_cell <- sapply(X = tmp_idents, FUN = `[[`, 2)
  ligand <- sapply(X = tmp_pairs, FUN = `[[`, 1)
  receptor <- sapply(X = tmp_pairs, FUN = `[[`, 2)
  cell_pair <- paste(ligand_cell, receptor_cell, sep = '_')
  lr_pair <- paste(ligand, receptor, sep = '_')
  tmp_scores <- exp_scores %>% reshape2::melt() %>% .[['value']]
  tmp_avg_l <- c(exp_avg_lig)
  tmp_avg_r <- c(exp_avg_rec)
  tmp_pvals <- pvals %>% reshape2::melt() %>% .[['value']]
  if (adjust_pval) {
    tmp_adj_pvals <- adj_pvals %>% reshape2::melt() %>% .[['value']]  
  }
  tmp_pct <- exp_pct %>% as.matrix()
  tmp_pct_l <- c(tmp_pct[index_x, index_l])
  tmp_pct_r <- c(tmp_pct[index_y, index_r])
  split_var <- NA
  if (!is.null(split_by)) {
    split_var <- sapply(X = tmp_idents, FUN = `[[`, 3)
    split_var <- factor(x = split_var, levels = levels(lr_data[[split_by]]))
    cell_prop <- round(prop.table(cell_counts, margin = 1), 3)*100
    tmp_count_l <- mapply(FUN = function(x,y) cell_prop[x,y], ligand_cell, split_var)
    tmp_count_r <- mapply(FUN = function(x,y) cell_prop[x,y], receptor_cell, split_var)
  }
  
  # Final result compilation
  results <- data.frame(
    'Pair_name' = lr_pair,
    'Score' = tmp_scores,
    'pval' = tmp_pvals,
    'adj_pval' = ifelse(test = exists('tmp_adj_pvals'), yes = tmp_adj_pvals, no = NA),
    'Ligand_cell' = ligand_cell,
    'Receptor_cell' = receptor_cell,
    'split_by' = split_var,
    'Ligand' = ligand,
    'Receptor' = receptor,
    'Ligand_avgExp' = tmp_avg_l,
    'Receptor_avgExp' = tmp_avg_r,
    'Ligand_pct' = tmp_pct_l,
    'Receptor_pct' = tmp_pct_r,
    'Cell_pair' = cell_pair,
    'LR_pair' = lr_pair,
    stringsAsFactors = FALSE
  )
  if (!is.null(split_by)) {
    results[['Ligand_cell_pct']] <- tmp_count_l
    results[['Receptor_cell_pct']] <- tmp_count_r
  }
  message('Done!')
  return(results)
}
```


```{r compute_lr}
# celltype
Idents(svz) <- 'celltype'
svz_setup <- setupLR(
  seurat_object = svz,
  lr_ref = lr_ref,
  split_by = 'orig.ident'
)
svz_results <- calculateLR(
  setup = svz_setup,
  resample = 10000,
  adjust_pval = TRUE
)
write.table(x = svz_results,
            file = paste0(results_out, 'SVZ_celltype_LRanalysis.csv'),
            sep = ',',
            quote = FALSE,
            row.names = FALSE)
# subtype 
Idents(svz) <- 'subtype'
svz_setup <- setupLR(
  seurat_object = svz,
  lr_ref = lr_ref,
  split_by = 'orig.ident'
)
svz_results <- calculateLR(
  setup = svz_setup,
  resample = 10000,
  adjust_pval = TRUE
)
write.table(x = svz_results,
            file = paste0(results_out, 'SVZ_subtype_LRanalysis.csv'),
            sep = ',',
            quote = FALSE,
            row.names = FALSE)
```


```{r gene_pairs_params}
gene_pairs <- c('Apoe_Lrp8',
                'B2m_Tfrc', 
                'C1qa_Cr1l',
                'Cd14_Itgb1',
                'Igf2_Igf1r',
                'Lgals3bp_Itgb1',
                'Pros1_Tyro3')
pair_cols <- c('#800000', 
               '#f58231', 
               '#ffe119', 
               '#42d4f4', 
               '#000075',
               '#4363d8', 
               '#dcbeff')
names(pair_cols) <- gene_pairs
grid_cols <- c('Neuroblast' = '#ffe119',
               'Quiescent B Cell' = '#e6194B',
               'Activated B Cell' = '#800000',
               'C Cell' = '#f58231',
               'Homeostatic MG' = '#000075',
               'Activated MG' = '#f032e6', 
               'Unknown MG' = '#4363d8',
               'Development-associated MG' = '#3cb44b',
               'Disease-associated MG' = '#42d4f4')
```


```{r celltype_results_lr}
lr_celltype <- read.csv(file = paste0(results_out, 'SVZ_celltype_LRanalysis.csv'))

# DEG between time points within microglia
Idents(svz) <- 'celltype'
mg_deg1 <- FindMarkers(
  object = svz,
  subset.ident = 'Microglia',
  group.by = 'orig.ident',
  ident.1 = 'SCtrl',
  ident.2 = 'S1d',
  assay = 'RNA',
  slot = 'data',
  only.pos = FALSE
) %>%
  filter(p_val < 0.001) %>% 
  rownames()
mg_deg2 <- FindMarkers(
  object = svz,
  subset.ident = 'Microglia',
  group.by = 'orig.ident',
  ident.1 = 'S1d',
  ident.2 = 'S7d',
  assay = 'RNA',
  slot = 'data',
  only.pos = FALSE
) %>%
  filter(p_val < 0.001) %>% 
  rownames()
mg_deg3 <- FindMarkers(
  object = svz,
  subset.ident = 'Microglia',
  group.by = 'orig.ident',
  ident.1 = 'SCtrl',
  ident.2 = 'S7d',
  assay = 'RNA',
  slot = 'data',
  only.pos = FALSE
) %>%
  filter(p_val < 0.001) %>% 
  rownames()
mg_deg <- unique(c(mg_deg1, mg_deg2, mg_deg3))

# DEG between time points within NSC
nsc_deg1 <- FindMarkers(
  object = svz,
  subset.ident = 'NSC',
  group.by = 'orig.ident',
  ident.1 = 'SCtrl',
  ident.2 = 'S1d',
  assay = 'RNA',
  slot = 'data',
  only.pos = FALSE
) %>%
  filter(p_val < 0.001) %>% 
  rownames()
nsc_deg2 <- FindMarkers(
  object = svz,
  subset.ident = 'NSC',
  group.by = 'orig.ident',
  ident.1 = 'S1d',
  ident.2 = 'S7d',
  assay = 'RNA',
  slot = 'data',
  only.pos = FALSE
) %>%
  filter(p_val < 0.001) %>% 
  rownames()
nsc_deg3 <- FindMarkers(
  object = svz,
  subset.ident = 'NSC',
  group.by = 'orig.ident',
  ident.1 = 'SCtrl',
  ident.2 = 'S7d',
  assay = 'RNA',
  slot = 'data',
  only.pos = FALSE
) %>%
  filter(p_val < 0.001) %>% 
  rownames()
nsc_deg <- unique(c(nsc_deg1, nsc_deg2, nsc_deg3))

lr_dat <- lr_celltype %>% 
  filter(Pair_name %in% lr_ref$Pair.Name[lr_ref$Pair.Evidence == 'literature supported']) %>% 
  mutate(Pair_name = factor(Pair_name, 
                            levels = sort(unique(Pair_name),
                                          decreasing = TRUE))) %>% 
  # group_by(Pair_name) %>% 
  # mutate(Standard.Score = as.numeric(scale(Score))) %>% 
  mutate(split_by = factor(split_by, levels = c('SCtrl', 'S1d', 'S7d'))) %>% 
  mutate(log_pval = ifelse(pval == 0, 4, -log10(pval))) %>% 
  # filter(Ligand %in% nsc_deg) %>% 
  filter(Ligand %in% mg_deg) %>% 
  filter(Ligand_cell == 'Microglia') %>% 
  filter(Receptor_cell == 'NSC') %>% 
  # filter(Ligand %in% c('Apoe','B2m','Igf2')) %>% 
  mutate(Set = ifelse(Ligand <= 'Gnai2', 1, 2))

lr_celltype_plot1 <- lr_dat %>% 
  filter(Set == 1) %>% 
  ggplot(mapping = aes(x = split_by, y = Pair_name)) +
  geom_point(mapping = aes(size = log_pval, fill = Score),
             pch = 21, color = 'black') +
  scale_fill_gradientn(colors = rev(RColorBrewer::brewer.pal(9,'Spectral')),
                       breaks = seq(0, 5, 0.5),
                       labels = seq(0, 5, 0.5),
                       limits = c(0, NA)) +
  facet_grid(Ligand ~ ., drop = TRUE, scales = 'free_y', space = 'free_y') +
  theme(strip.background.x = element_rect(color = NA, fill = NA),
        strip.background.y = element_rect(color = 'black', fill = NA),
        strip.text.y = element_text(size = 12, angle = 0),
        panel.background = element_rect(color = NA, fill = NA),
        panel.border = element_rect(color = NA, fill = NA),
        axis.line = element_line(color = 'black'),
        axis.line.y.right = element_line(color = 'black'),
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.key = element_rect(color = NA, fill = NA)) +
  guides(fill = guide_colorbar(frame.colour = 'black',
                               ticks.colour = 'black',
                               barwidth = unit(x = 5, units = 'mm'),
                               barheight = unit(x = 25, units = 'mm')),
         size = guide_legend(title = 'Log10(p-value)',
                             override.aes = list(color = 'black',
                                                 fill = 'black')))
lr_celltype_plot2 <- lr_dat %>% 
  filter(Set == 2) %>% 
  ggplot(mapping = aes(x = split_by, y = Pair_name)) +
  geom_point(mapping = aes(size = log_pval, fill = Score),
             pch = 21, color = 'black') +
  scale_fill_gradientn(colors = rev(RColorBrewer::brewer.pal(9,'Spectral')),
                       breaks = seq(0, 5, 0.5),
                       labels = seq(0, 5, 0.5),
                       limits = c(0, NA)) +
  facet_grid(Ligand ~ ., drop = TRUE, scales = 'free_y', space = 'free_y') +
  theme(strip.background.x = element_rect(color = NA, fill = NA),
        strip.background.y = element_rect(color = 'black', fill = NA),
        strip.text.y = element_text(size = 12, angle = 0),
        panel.background = element_rect(color = NA, fill = NA),
        panel.border = element_rect(color = NA, fill = NA),
        axis.line = element_line(color = 'black'),
        axis.line.y.right = element_line(color = 'black'),
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.key = element_rect(color = NA, fill = NA)) +
  guides(fill = guide_colorbar(frame.colour = 'black',
                               ticks.colour = 'black',
                               barwidth = unit(x = 5, units = 'mm'),
                               barheight = unit(x = 25, units = 'mm')),
         size = guide_legend(title = 'Log10(p-value)',
                             override.aes = list(color = 'black',
                                                 fill = 'black')))
lr_legend <- cowplot::get_legend(plot = lr_celltype_plot1)
p1 <- lr_celltype_plot1 + theme(legend.position = 'none')
p2 <- lr_celltype_plot2 + theme(legend.position = 'none')
p3 <- (p1 | p2 | lr_legend) + patchwork::plot_layout(widths = c(1,1,1.5))
ggsave(filename = paste0(results_out, 'LR_unbiased_deg_celltype.svg'),
       plot = p3, device = 'svg', height = 10, width = 7, units = 'in')
ggsave(filename = paste0(results_out, 'LR_unbiased_deg_celltype.tiff'),
       plot = p3, device = 'tiff', height = 10, width = 7, units = 'in')
```


```{r load_results}
lr <- read.csv(file = paste0(results_out, 'SVZ_subtype_LRanalysis.csv'))
grid_cols <- c('Neuroblast' = '#ffe119',
               'Quiescent B Cell' = '#e6194B',
               'Activated B Cell' = '#800000',
               'C Cell' = '#f58231',
               'Homeostatic MG' = '#000075',
               'Activated MG' = '#f032e6', 
               'Unknown MG' = '#4363d8',
               'Development-associated MG' = '#3cb44b',
               'Disease-associated MG' = '#42d4f4')
mg_subtype <- c('Homeostatic MG', 'Activated MG', 'Unknown MG', 'Development-associated MG', 'Disease-associated MG')
nsc_subtype <- c('Neuroblast', 'Quiescent B Cell', 'Activated B Cell', 'C Cell')
# lr$Ligand_cell <- plyr::mapvalues(
#   x = lr$Ligand_cell,
#   from = c(paste0('NSC.', 0:3), paste0("MG.", 0:4)),
#   to = c(nsc_subtype, mg_subtype)
# )
# lr$Receptor_cell <- plyr::mapvalues(
#   x = lr$Receptor_cell,
#   from = c(paste0('NSC.', 0:3), paste0("MG.", 0:4)),
#   to = c(nsc_subtype, mg_subtype)
# )
```

```{r select_gene}
genes <- c('Apoe','Lrp8')
lr_counts <- data.frame(t(Matrix::as.matrix(svz[['RNA']]@data[genes,])))
lr_meta <- svz@meta.data[c('subtype','celltype','orig.ident')]
```


```{r chord_diagram_width-counts_color-score}
cell_counts <- table(lr_meta$subtype, lr_meta$orig.ident)
cell_counter <- function(x, y) {
  return(cell_counts[x, y])
}
lr_sub <- lr[lr$Pair_name == paste(genes, collapse = '_'),]
lr_sub$Ligand_cell_count <- mapply(
   FUN = cell_counter,
   x = lr_sub$Ligand_cell,
   y = lr_sub$split_by
)
lr_sub$Receptor_cell_count <- mapply(
   FUN = cell_counter,
   x = lr_sub$Receptor_cell,
   y = lr_sub$split_by
)

splits <- unique(lr_sub$split_by)
splits <- c('S1d', 'S7d', 'SCtrl')
chord_data <- vector(mode = 'list', length = length(splits))
names(chord_data) <- splits
for (i in 1:length(splits)) {
  chord_data[[i]] <- lr_sub |>
    filter(split_by == splits[i]) |>
  filter(Ligand_cell %in% mg_subtype) |>
  filter(Receptor_cell %in% nsc_subtype) |>
  filter(!is.na(Score))
  chord_data[[i]]$Ligand_cell <- factor(
    x = chord_data[[i]]$Ligand_cell,
    levels = rev(c(mg_subtype, nsc_subtype))
  )
  chord_data[[i]]$Receptor_cell <- factor(
    x = chord_data[[i]]$Receptor_cell,
    levels = rev(c(mg_subtype, nsc_subtype))
  )
}
set_first <- function(x) {
  ind <- 1:ncol(x)
  these_first <- c('Ligand_cell', 'Receptor_cell', 'Ligand_cell_count', 'Receptor_cell_count')
  ind[which(colnames(x) %in% these_first)] <- 1:length(these_first)
  ind[1:length(these_first)] <- which(colnames(x) %in% these_first)
  return(x[order(x$Score, decreasing = FALSE),ind])
}
chord_data <- lapply(X = chord_data, FUN = set_first)
chord_data <- chord_data[c('SCtrl','S1d','S7d')]
chord_data <- lapply(X = chord_data,
                     FUN = function(x) x %>% arrange(Ligand_cell, Receptor_cell))
chord_data <- lapply(X = chord_data, FUN = function(x) {
  x$Ligand_cell_count <- x$Ligand_cell_count/4
  x$Receptor_cell_count <- x$Receptor_cell_count/4
  return(x)
})

file_out <- paste0(results_out, 'LR-chord-diagram_color-score_width-cell-counts.svg')
svg(filename = file_out, height = 3.5, width = 9)
{
  sectors <- unique(c(as.character(unique(lr_sub$Ligand_cell)),
                      as.character(unique(lr_sub$Ligand_cell))))
  scaled_vals <- unlist(
    x = sapply(chord_data, `[`, 'Score'),
    use.names = FALSE
  )
  my_cols_fxn <- colorRamp2(
    breaks = range(scaled_vals),
    colors = c('grey90', 'red3'),
    transparency = 0
  )
  
  tmp_score <- chord_data[[1]]$Score
  tmp_score[chord_data[[1]]$Ligand_cell != 'Disease-associated MG'] <- NA
  tmp_cols <- my_cols_fxn(tmp_score)
  tmp_cols[is.na(tmp_cols)] <- 'grey90'
  par(mfrow = c(1,length(chord_data)))
  circos.par(circle.margin = c(0.1,0.05))
  chordDiagram(chord_data[[1]], 
               grid.col = grid_cols, 
               col = tmp_cols,
               annotationTrack = 'grid', 
               link.zindex = rev(order(chord_data[[1]]$Ligand_cell)),
               transparency = 0)
  tmp_sectors <- sectors[sectors %in% unlist(chord_data[[1]][c(1,2)])]
  for (i in 1:length(tmp_sectors)) {
    circos.axis(sector.index = tmp_sectors[i],
                major.at = seq(0, 200, 10),
                labels.cex = 1)
  }
  title(main = names(chord_data)[1], cex.main = 2, line = -1)
  tmp_score <- chord_data[[2]]$Score
  tmp_score[chord_data[[2]]$Ligand_cell != 'Disease-associated MG'] <- NA
  tmp_cols <- my_cols_fxn(tmp_score)
  tmp_cols[is.na(tmp_cols)] <- 'grey90'
  circos.par(circle.margin = c(0.1,0.05))
  chordDiagram(chord_data[[2]], 
               grid.col = grid_cols, 
               col = tmp_cols,
               annotationTrack = 'grid', 
               link.zindex = rev(order(chord_data[[2]]$Ligand_cell)),
               transparency = 0)
  tmp_sectors <- sectors[sectors %in% unlist(chord_data[[2]][c(1,2)])]
  for (i in 1:length(tmp_sectors)) {
    circos.axis(sector.index = tmp_sectors[i],
                major.at = seq(0, 200, 10),
                labels.cex = 1)
  }
  title(main = names(chord_data)[2], cex.main = 2, line = -1)
  
  tmp_score <- chord_data[[3]]$Score
  tmp_score[chord_data[[3]]$Ligand_cell != 'Disease-associated MG'] <- NA
  tmp_cols <- my_cols_fxn(tmp_score)
  tmp_cols[is.na(tmp_cols)] <- 'grey90'
  circos.par(circle.margin = c(0.1,0.05))
  chordDiagram(chord_data[[3]], 
               grid.col = grid_cols, 
               col = tmp_cols,
               annotationTrack = 'grid', 
               link.zindex = rev(order(chord_data[[3]]$Ligand_cell)),
               transparency = 0)
  tmp_sectors <- sectors[sectors %in% unlist(chord_data[[3]][c(1,2)])]
  for (i in 1:length(tmp_sectors)) {
    circos.axis(sector.index = tmp_sectors[i],
                major.at = seq(0, 200, 10),
                labels.cex = 1)
  }
  title(main = names(chord_data)[3], cex.main = 2, line = -1)
  
  circos.clear()
}
dev.off()
```

```{r chord_diagram_width-counts_color-score_unlabeled}
cell_counts <- table(lr_meta$subtype, lr_meta$orig.ident)
cell_counter <- function(x, y) {
  return(cell_counts[x, y])
}
lr_sub <- lr[lr$Pair_name == paste(genes, collapse = '_'),]
lr_sub$Ligand_cell_count <- mapply(
   FUN = cell_counter,
   x = lr_sub$Ligand_cell,
   y = lr_sub$split_by
)
lr_sub$Receptor_cell_count <- mapply(
   FUN = cell_counter,
   x = lr_sub$Receptor_cell,
   y = lr_sub$split_by
)

splits <- unique(lr_sub$split_by)
splits <- c('S1d', 'S7d', 'SCtrl')
chord_data <- vector(mode = 'list', length = length(splits))
names(chord_data) <- splits
for (i in 1:length(splits)) {
  chord_data[[i]] <- lr_sub |>
    filter(split_by == splits[i]) |>
  filter(Ligand_cell %in% mg_subtype) |>
  filter(Receptor_cell %in% nsc_subtype) |>
  filter(!is.na(Score))
  chord_data[[i]]$Ligand_cell <- factor(
    x = chord_data[[i]]$Ligand_cell,
    levels = rev(c(mg_subtype, nsc_subtype))
  )
  chord_data[[i]]$Receptor_cell <- factor(
    x = chord_data[[i]]$Receptor_cell,
    levels = rev(c(mg_subtype, nsc_subtype))
  )
}
set_first <- function(x) {
  ind <- 1:ncol(x)
  these_first <- c('Ligand_cell', 'Receptor_cell', 'Ligand_cell_count', 'Receptor_cell_count')
  ind[which(colnames(x) %in% these_first)] <- 1:length(these_first)
  ind[1:length(these_first)] <- which(colnames(x) %in% these_first)
  return(x[order(x$Score, decreasing = FALSE),ind])
}
chord_data <- lapply(X = chord_data, FUN = set_first)
chord_data <- chord_data[c('SCtrl','S1d','S7d')]
chord_data <- lapply(X = chord_data,
                     FUN = function(x) x %>% arrange(Ligand_cell, Receptor_cell))
chord_data <- lapply(X = chord_data, FUN = function(x) {
  x$Ligand_cell_count <- x$Ligand_cell_count/4
  x$Receptor_cell_count <- x$Receptor_cell_count/4
  return(x)
})

# file_out <- paste0(results_out, 'LR-chord-diagram_color-score_width-cell-counts_unlabeled.svg')
# svg(filename = file_out, height = 3.5, width = 9)
file_out <- paste0(results_out, 'LR-chord-diagram_color-score_width-cell-counts_unlabeled.tiff')
tiff(filename = file_out, height = 3.5, width = 9, res = 440, units = 'in')
{
  # circos.par(gap.degree = 0.5)
  scaled_vals <- unlist(
    x = sapply(chord_data, `[`, 'Score'),
    use.names = FALSE
  )
  my_cols_fxn <- colorRamp2(
    breaks = range(scaled_vals),
    colors = c('grey90', 'red3'),
    transparency = 0
  )
  
  tmp_score <- chord_data[[1]]$Score
  tmp_score[chord_data[[1]]$Ligand_cell != 'Disease-associated MG'] <- NA
  tmp_cols <- my_cols_fxn(tmp_score)
  tmp_cols[is.na(tmp_cols)] <- 'grey90'
  par(mfrow = c(1,length(chord_data)))
  circos.par(circle.margin = c(0.1,0.05))
  chordDiagram(chord_data[[1]], 
               grid.col = grid_cols, 
               col = tmp_cols,
               annotationTrack = 'grid', 
               link.zindex = rev(order(chord_data[[1]]$Ligand_cell)),
               transparency = 0)
  title(main = names(chord_data)[1], cex.main = 2, line = -1)
  tmp_score <- chord_data[[2]]$Score
  tmp_score[chord_data[[2]]$Ligand_cell != 'Disease-associated MG'] <- NA
  tmp_cols <- my_cols_fxn(tmp_score)
  tmp_cols[is.na(tmp_cols)] <- 'grey90'
  circos.par(circle.margin = c(0.1,0.05))
  chordDiagram(chord_data[[2]], 
               grid.col = grid_cols, 
               col = tmp_cols,
               annotationTrack = 'grid', 
               link.zindex = rev(order(chord_data[[2]]$Ligand_cell)),
               transparency = 0)
  title(main = names(chord_data)[2], cex.main = 2, line = -1)
  
  tmp_score <- chord_data[[3]]$Score
  tmp_score[chord_data[[3]]$Ligand_cell != 'Disease-associated MG'] <- NA
  tmp_cols <- my_cols_fxn(tmp_score)
  tmp_cols[is.na(tmp_cols)] <- 'grey90'
  circos.par(circle.margin = c(0.1,0.05))
  chordDiagram(chord_data[[3]], 
               grid.col = grid_cols, 
               col = tmp_cols,
               annotationTrack = 'grid', 
               link.zindex = rev(order(chord_data[[3]]$Ligand_cell)),
               transparency = 0)
  title(main = names(chord_data)[3], cex.main = 2, line = -1)
  
  circos.clear()
}
dev.off()
```

```{r chord_by_sum-counts}
lr_dat <- cbind(lr_meta, lr_counts) %>% 
  group_by(celltype, subtype, orig.ident) %>%
  summarise(across(.cols = where(is.numeric), 
                   .fns = sum)) %>% 
  ungroup() %>%
  group_by(celltype) %>%
  mutate(across(.cols = where(is.numeric),
                .fns = function(x) x / sum(x)))
lr_sub <- lr[lr$Pair_name == paste(genes, collapse = '_'),]
lr_sub$sum_ligand <- lr_dat[[4]][match(lr_sub$Ligand_cell, lr_dat$subtype)]
lr_sub$sum_receptor <- lr_dat[[5]][match(lr_sub$Receptor_cell, lr_dat$subtype)]

splits <- unique(lr$split_by)
splits <- c('S1d', 'S7d', 'SCtrl')
chord_data <- vector(mode = 'list', length = length(splits))
names(chord_data) <- splits
for (i in 1:length(splits)) {
  chord_data[[i]] <- lr_sub |>
    filter(split_by == splits[i]) |>
  filter(Ligand_cell %in% mg_subtype) |>
  filter(Receptor_cell %in% nsc_subtype) |>
  filter(!is.na(Score))
}
set_first <- function(x) {
  ind <- 1:ncol(x)
  these_first <- c('Ligand_cell', 'Receptor_cell', 'sum_ligand', 'sum_receptor')
  ind[which(colnames(x) %in% these_first)] <- 1:length(these_first)
  ind[1:length(these_first)] <- which(colnames(x) %in% these_first)
  return(x[,ind])
}
chord_data <- lapply(X = chord_data, FUN = set_first)
file_out <- paste0(results_out, 'LR-chord-diagram_color-subtype_width-exp-counts.svg')
svg(filename = file_out, height = 3, width = 13)
{
  par(mfrow = c(1,length(chord_data)))
  chordDiagram(chord_data[[1]], grid.col = grid_cols)
  title(main = names(chord_data)[1])
  chordDiagram(chord_data[[2]], grid.col = grid_cols)
  title(main = names(chord_data)[2])
  chordDiagram(chord_data[[3]], grid.col = grid_cols)
  title(main = names(chord_data)[3])
}
dev.off()
```



```{r chord_by_scaled-score}
lr_dat <- cbind(lr_meta, lr_counts) %>% 
  group_by(celltype, subtype, orig.ident) %>%
  summarise('count' = n()) %>% 
  ungroup() %>% 
  group_by(celltype) %>% 
  mutate('prop' = count / sum(count)) %>% 
  ungroup()
lr_sub <- lr %>% 
  filter(Pair_name == paste(genes, collapse = '_')) %>%
  group_by(Pair_name) %>% 
  mutate('scaled.score' = as.numeric(scale(Score)))
lr_sub$count_ligand_cell <- lr_dat[['prop']][match(lr_sub$Ligand_cell, lr_dat$subtype)]
lr_sub$count_receptor_cell <- lr_dat[['prop']][match(lr_sub$Receptor_cell, lr_dat$subtype)]

splits <- unique(lr$split_by)
splits <- c('S1d', 'S7d', 'SCtrl')
chord_data <- vector(mode = 'list', length = length(splits))
names(chord_data) <- splits
for (i in 1:length(splits)) {
  chord_data[[i]] <- lr_sub |>
    filter(split_by == splits[i]) |>
  filter(Ligand_cell %in% mg_subtype) |>
  filter(Receptor_cell %in% nsc_subtype) |>
  filter(!is.na(Score))
}
set_first <- function(x) {
  ind <- 1:ncol(x)
  these_first <- c('Ligand_cell', 'Receptor_cell', 'count_ligand_cell', 'count_receptor_cell')
  ind[which(colnames(x) %in% these_first)] <- 1:length(these_first)
  ind[1:length(these_first)] <- which(colnames(x) %in% these_first)
  return(x[,ind])
}
chord_data <- lapply(X = chord_data, FUN = set_first)
file_out <- paste0(results_out, 'LR-chord-diagram_color-scaled-expression_width-subtype-count.svg')
svg(filename = file_out, height = 3, width = 13)
{
  scaled_vals <- unlist(
    x = sapply(chord_data, FUN = `[`, 'scaled.score'),
    use.names = FALSE
  )
  my_cols_fxn <- colorRamp2(
    breaks = range(scaled_vals),
    colors = c('grey80', 'red3'),
    transparency = 0.5
  )
  par(mfrow = c(1,length(chord_data)))
  chordDiagram(chord_data[[1]], grid.col = grid_cols, 
               col = my_cols_fxn(chord_data[[1]]$scaled.score))
  title(main = names(chord_data)[1])
  chordDiagram(chord_data[[2]], grid.col = grid_cols, 
               col = my_cols_fxn(chord_data[[2]]$scaled.score))
  title(main = names(chord_data)[2])
  chordDiagram(chord_data[[3]], grid.col = grid_cols, 
               col = my_cols_fxn(chord_data[[3]]$scaled.score))
  title(main = names(chord_data)[3])
  circos.clear()
}
dev.off()
```


```{r}
chords <- vector(mode = 'list', length = length(unique(lr$split_by))) # Change length 
names(chords) <- unique(lr$split_by)
for (i in 1:length(chords)) {
  split_var <- names(chords)[i]
  chords[[i]] <- lr |>
    filter(split_by %in% split_var) |>
    # filter(pval < 0.05) |> 
    mutate(Score = ifelse(pval >= 0.05 | is.na(Score), 0, Score)) |> 
    filter(Pair_name %in% gene_pairs) |> 
    filter(grepl(pattern = 'NSC', x = Receptor_cell)) |>
    filter(grepl(pattern = 'MG', x = Ligand_cell)) |>
    group_by(Ligand_cell, Receptor_cell) |> 
    select(c('Ligand_cell', 'Receptor_cell', 'Score', 'Pair_name'))
  chords[[i]]$Ligand_cell <- plyr::mapvalues(
    x = chords[[i]]$Ligand_cell,
    from = paste0("MG.", 0:4),
    to = names(grid_cols)[5:length(grid_cols)]
  )
  chords[[i]]$Receptor_cell <- plyr::mapvalues(
    x = chords[[i]]$Receptor_cell,
    from = paste0('NSC.', 0:3),
    to = names(grid_cols)[1:4]
  )
  chords[[i]]
}

if (any(sapply(X = chords, FUN = function(x) any(is.na(x[['Score']]))))) {
  stop('Some scores are NA.')
}

for (i in 1:length(chords)) {
  file_out <- paste0(results_out, names(chords)[i], '_LR-chord-diagram.tiff')
  tiff(filename = file_out, height = 3, width = 3, res = 440, unit = 'in')
  circos.par(gap.degree = 0)
  chordDiagram(chords[[i]], grid.col = grid_cols, col = pair_cols)
  circos.clear()
  dev.off()
}
```

```{r}
lr <- read.csv(file = paste0(results_out, 'SVZ_celltype_LRanalysis.csv'))
lr %>% 
  mutate('logp' = ifelse(is.infinite(log10(pval)), 3, -log10(pval))) %>% 
  filter(Ligand_cell %in% mg_subtype) %>% 
  filter(Receptor_cell %in% nsc_subtype) %>% 
  filter(Pair_name == 'Apoe_Lrp8') %>% 
  ggplot(mapping = aes(x = Pair_name, y = Ligand_cell)) +
  geom_point(mapping = aes(color = Score, size = logp)) +
  facet_grid(Receptor_cell ~ split_by)
lr %>% 
  mutate('logp' = ifelse(is.infinite(log10(pval)), 3, -log10(pval))) %>% 
  filter(Ligand_cell %in% 'Microglia') %>% 
  filter(Receptor_cell %in% 'NSC') %>% 
  filter(Pair_name == 'Apoe_Lrp8') %>% 
  ggplot(mapping = aes(x = Pair_name, y = Ligand_cell)) +
  geom_point(mapping = aes(color = Score, size = logp)) +
  facet_grid(Receptor_cell ~ split_by)
```


```{r test}
# Highlight only DAM arcs
# if !DAM make grey else scale red colors via score
# arc width by cell.
lr_dat <- cbind(lr_meta, lr_counts) %>% 
  group_by(celltype, subtype, orig.ident) %>%
  summarise(across(.cols = where(is.numeric), 
                   .fns = sum)) %>% 
  ungroup() %>%
  group_by(celltype) %>%
  mutate(across(.cols = where(is.numeric),
                .fns = function(x) x / sum(x)))

lr_sub <- lr[lr$Pair_name == paste(genes, collapse = '_'),]
lr_sub$sum_ligand <- lr_dat[[4]][match(lr_sub$Ligand_cell, lr_dat$subtype)]
lr_sub$sum_receptor <- lr_dat[[5]][match(lr_sub$Receptor_cell, lr_dat$subtype)]

cell_counts <- table(svz$subtype, svz$orig.ident)
get_counts <- function(type, time) {
  return(cell_counts[type, time])
}
lr_sub$Ligand_cell_count <- 0
for (i in 1:nrow(lr_sub)) {
  lr_sub$Ligand_cell_count[i] <- get_counts(type = lr_sub$Ligand_cell[i],
                                            time = lr_sub$split_by[i])
}
lr_sub$Receptor_cell_count <- 0
for (i in 1:nrow(lr_sub)) {
  lr_sub$Receptor_cell_count[i] <- get_counts(type = lr_sub$Receptor_cell[i],
                                            time = lr_sub$split_by[i])
}
splits <- unique(lr$split_by)
splits <- c('S1d', 'S7d', 'SCtrl')
chord_data <- vector(mode = 'list', length = length(splits))
names(chord_data) <- splits
for (i in 1:length(splits)) {
  chord_data[[i]] <- lr_sub |>
    filter(split_by == splits[i]) |>
  filter(Ligand_cell %in% 'Disease-associated MG') |>
  filter(Receptor_cell %in% nsc_subtype) |>
  filter(!is.na(Score))
}
set_first <- function(x) {
  ind <- 1:ncol(x)
  these_first <- c('Ligand_cell', 'Receptor_cell', 'Ligand_cell_count', 'Receptor_cell_count')
  ind[which(colnames(x) %in% these_first)] <- 1:length(these_first)
  ind[1:length(these_first)] <- which(colnames(x) %in% these_first)
  return(x[,ind])
}
chord_data <- lapply(X = chord_data, FUN = set_first)
file_out <- paste0(results_out, 'LR-chord-diagram_color-subtype_width-exp-counts.svg')
svg(filename = file_out, height = 3, width = 13)
{
  scaled_vals <- unlist(
    x = sapply(chord_data, FUN = `[`, 'Score'),
    use.names = FALSE
  )
  my_cols_fxn <- colorRamp2(
    breaks = range(scaled_vals),
    colors = c('grey80', 'red3'),
    transparency = 0.5
  )
  par(mfrow = c(1,length(chord_data)))
  chordDiagram(chord_data[[1]], grid.col = grid_cols,
               col = my_cols_fxn(chord_data[[1]]$Score))
  title(main = names(chord_data)[1])
  chordDiagram(chord_data[[2]], grid.col = grid_cols,
               col = my_cols_fxn(chord_data[[2]]$Score))
  title(main = names(chord_data)[2])
  chordDiagram(chord_data[[3]], grid.col = grid_cols,
               col = my_cols_fxn(chord_data[[3]]$Score))
  title(main = names(chord_data)[3])
}
dev.off()


  
  par(mfrow = c(1,length(chord_data)))
  chordDiagram(chord_data[[1]], grid.col = grid_cols, 
               col = my_cols_fxn(chord_data[[1]]$scaled.score))
```