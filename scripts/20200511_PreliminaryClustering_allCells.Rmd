---
title: "Suvra scSeq"
author: "James Choi"
date: "`r Sys.Date()`"
output:  
  html_document:
    keep_md: true
    code_folding: hide
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE, fig.width=6, fig.height=5)
data_inpath <- '../data/raw_counts_all_cells.csv'
cc_genes_path <- '../ref/regev_lab_cell_cycle_genes.txt'
results_outpath <- '../results/20200511_PreliminaryClustering/'
set.seed(123)
```

### Loading libraries

```{r load_libraries, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
dir.create(path = results_outpath)
library('SingleCellExperiment')
library('Seurat')
library('dplyr')
library('ggplot2')
```

### Loading data

```{r load_data, echo=TRUE, message=FALSE, warning=FALSE}
dat <- read.table(file = data_inpath, sep = ',', stringsAsFactors = FALSE, row.names = 1, header = TRUE)
dat <- Matrix::Matrix(data = as.matrix(dat), sparse = TRUE)
dat <- round(dat) # for some reason, counts are non-integers....
dat_sce <- SingleCellExperiment(assay = list('counts' = dat))
dat <- CreateSeuratObject(counts = dat, project = 'SVZ', assay = 'RNA')
# For SCE objects:
# dat[['sample']] <- sapply(X = strsplit(x = colnames(dat), split = '_'), FUN = `[`, 1)
```


---------------------------------------------------------------------------------


### Basic quality control

```{r detection_scatter_sample}
tmp <- dat@meta.data
tmp <- tmp[sample(x = nrow(tmp), size = nrow(tmp)),]
tiff(filename = paste0(results_outpath, 'detection_scatterplot.tiff'), height = 1500, width = 1800, res = 220)
plot(x = tmp$nCount_RNA,
     y = tmp$nFeature_RNA,
     xlab = 'total UMI',
     ylab = '# genes detected',
     main = 'Detection rates by sample',
     sub = 'Black = SCtrl; Red = S1d; Green = S7d',
     col = sapply(X = as.character(tmp$orig.ident), FUN = function(x) switch(x, 'SCtrl' = 'black', 'S1d' = 'red3', 'S7d' = 'green')))
dev.off()
```

From the above, we see that there are a few cells with outlier numbers of total UMI and genes detected. These are likely to be doublets. Beyond that, there are no obvious biases based on sample of origin.  

Next we compute gene-level and cell-level QC metrics.  

```{r cell_qc_metrics, fig.width=10}
dat <- PercentageFeatureSet(dat, pattern = '^mt-', col.name = 'percent.mt')
dat_sce <- as.SingleCellExperiment(x = dat)
mito_gene <- grep(pattern = '^mt-', x = rownames(dat_sce), value = TRUE)
dat_sce <- scater::calculateQCMetrics(object = dat_sce, exprs_values = 'counts', feature_controls = list('percent.mt' = mito_gene))
tmp <- as.data.frame(colData(dat_sce)[c('log10_total_counts',
                                        'log10_total_features_by_counts',
                                        'pct_counts_in_top_50_features',
                                        'pct_counts_in_top_100_features',  
                                        'pct_counts_in_top_200_features',
                                        'pct_counts_in_top_500_features',
                                        'log10_total_counts_percent.mt')])
dat@meta.data <- cbind(dat@meta.data, tmp)
qc_metrics_plot <- dat@meta.data %>%
  reshape2::melt(id.vars = 'orig.ident') %>%
  ggplot(mapping = aes(x = orig.ident, y = value)) +
  geom_violin(scale = 'width') +
  ggbeeswarm::geom_quasirandom(size = 0.25) +
  facet_wrap(. ~ variable, scales = 'free_y') +
  labs(title = 'Quality control metrics') +
  theme(axis.title = element_blank(),
        plot.title = element_text(size = 18, face = 'bold'),
        axis.line.y = element_line(size = 1),
        axis.ticks.y = element_line(size = 1))

qc_metrics_plot
```

In general, the samples share very similar distributions across quality control metrics. There are few outlier cells (see nCount_RNA i.e. library size). However, we note that the log library sizes (log10_total_counts) appear to have a bimodal distribution. (Note for JSC: previous "raw_counts_good_cells.csv" likely removed the lower mode during QC, which is why the total cells here are much greater than total cells previously, ~650 total). Additionally, we see that the percent of transcripts that map to mitochondrial genes have mean of `r round(mean(dat$percent.mt), 1)`%. The outlier cells with mito% greater than 3 median-absolute-deviations (`r median(dat$percent.mt) + 3*mad(dat$percent.mt, constant = 1)`) should be considered suspect.  

Since we cannot know whether the bimodal distributions are due to low-quality vs high-quality or true biological variation for now we will assume that most cells are of acceptable quality. Under this assumption, we can test two approaches for removing putative low-quality cells. The first is to apply a flat, adjustable threshold to each sample for each QC metric. The second is a multivariate approach via principal component analysis of all the QC metrics.  


Flat QC thresholds:  

```{r compute_qc_threshold, results = 'hold', fig.width=10, fig.height=5.5}
# Designate which QC metrics to base filter
qc_metric <- c('log10_total_features_by_counts',
               'log10_total_counts',
               'pct_counts_in_top_50_features',
               'pct_counts_in_top_100_features',
               'pct_counts_in_top_200_features',
               'pct_counts_in_top_500_features',
               'percent.mt')
# Calculate 4*MAD thresholds (two-way)
qc_threshold <- apply(X = dat@meta.data[qc_metric],
                      MARGIN = 2,
                      FUN = function(x) {
                        hi <- median(x) + 3*mad(x, constant = 1)
                        lo <- median(x) - 3*mad(x, constant = 1)
                        return(c('hi' = hi, 'lo' = lo))
                        })
# Determine which are outliers for each metric
tmp <- sapply(X = qc_metric,
              tmp_data = dat@meta.data,
              tmp_threshold = qc_threshold,
              FUN = function(xx, tmp_data, tmp_threshold) {
                vals <- tmp_data[[xx]]
                hi_thresh <- tmp_threshold['hi', xx]
                lo_thresh <- tmp_threshold['lo', xx]
                outlier <- vals > hi_thresh | vals < lo_thresh
                return(outlier)
              })
# If a cell is above/below thresholds for any metric, consider outlier.
tmp <- apply(X = tmp, MARGIN = 1, FUN = any)
dat$outlier <- tmp
table('sample' = dat$orig.ident, 'is outlier?' = dat$outlier)

# Plot the outlier cells in violin
qc_metrics_plot <- dat@meta.data %>%
  reshape2::melt(id.vars = c('orig.ident','outlier')) %>%
  ggplot(mapping = aes(x = orig.ident, y = value)) +
  geom_violin(scale = 'width') +
  ggbeeswarm::geom_quasirandom(mapping = aes(color = ifelse(outlier, 'True','False')), size = 0.25) +
  scale_color_manual(values = c('True' = 'red', 'False' = 'black')) +
  facet_wrap(. ~ variable, scales = 'free_y') +
  labs(title = 'Quality control metrics') +
  theme(axis.title = element_blank(),
        plot.title = element_text(size = 18, face = 'bold'),
        axis.line.y = element_line(size = 1),
        axis.ticks.y = element_line(size = 1),
        legend.key = element_rect(fill = NA),
        legend.position = 'bottom') +
  guides(color = guide_legend(title = 'Is outlier?'))
tiff(filename = paste0(results_outpath, 'qc_metrics_adaptiveThresholds.tiff'), height = 1500, width = 3000, res = 220)
qc_metrics_plot
dev.off()
```

Multivariate QC approach:  

```{r compute_qc_pca}
qc_metric <- c('log10_total_features_by_counts',
                'log10_total_counts',
                'pct_counts_in_top_50_features',
                'pct_counts_in_top_100_features',
                'pct_counts_in_top_200_features',
                'pct_counts_in_top_500_features',
                'percent.mt')
dat_sce <- scater::runPCA(x = dat_sce,
                          use_coldata = TRUE,
                          selected_variables = qc_metric,
                          detect_outliers = TRUE,
                          ncomponents = 2)
tiff(filename = paste0(results_outpath, 'qc_pca.tiff'), height = 1500, width = 1800, res = 220)
plot(dat_sce@reducedDims$PCA_coldata, 
     col = ifelse(dat_sce$outlier, 'red','black'),
     sub = 'Red = discarded outlier; Black = retained')
dev.off()
```

Gene-level metrics:  

```{r gene_qc_metrics, fig.height=7, fig.width=8.5}
scater::plotHighestExprs(dat_sce)
```


```{r filter_cells}
dat_full <- dat
dat <- dat[,dat$outlier == FALSE]
```

--------------------------------------------------------------------------------

### Basic cluster analysis

Now we do a preliminary cluster analysis to check that results are not strongly driven by what we would consider technical variation.  

```{r basic_cluster, echo=TRUE, results='hide', fig.width=6.5}
dat <- dat %>%
  NormalizeData() %>%
  FindVariableFeatures() %>%
  ScaleData() %>%
  RunPCA(npcs = 40)
# ElbowPlot(dat, ndims = 40)
dat <- dat %>%
  FindNeighbors(dims = 1:20) %>%
  RunTSNE(dims = 1:20) %>%
  FindClusters()
dat$orig.ident <- factor(dat$orig.ident, levels = c('SCtrl','S1d','S7d'))
# DimPlot(dat, label = TRUE, group.by = 'orig.ident')
```


```{r sample_umaps, fig.width=11, fig.height=4.5}
set.seed(123)
plot1 <- DimPlot(dat, group.by = 'orig.ident') + 
  theme(axis.line = element_line(size = 0.5),
        axis.ticks = element_blank(), 
        axis.text = element_blank(), 
        axis.title = element_text(size = 10), 
        panel.border = element_rect(color = 'black', fill = NA))
plot2 <- DimPlot(dat, group.by = 'seurat_clusters', label = TRUE, label.size = 6) + 
  theme(axis.line = element_line(size = 0.5),
        axis.ticks = element_blank(), 
        axis.text = element_blank(),
        axis.title = element_text(size = 10), 
        panel.border = element_rect(color = 'black', fill = NA))
plot <- cowplot::plot_grid(plot1, plot2, ncol = 2, rel_widths = c(1,0.925))
plot
ggsave(filename = paste0(results_outpath, 'preliminary_clustering_adaptiveQCThreshold.tiff'), plot = plot, device = 'tiff', height = 4.5, width = 11)
```


```{r qc_umap, fig.height=9, fig.width=10.75}
qc_metric <- c('log10_total_features_by_counts',
                'log10_total_counts',
                'pct_counts_in_top_50_features',
                'pct_counts_in_top_100_features',
                'pct_counts_in_top_200_features',
                'pct_counts_in_top_500_features',
                'percent.mt')
qc_tsne <- vector(mode = 'list', length = length(qc_metric))
names(qc_tsne) <- qc_metric
tmp <- cbind(dat@meta.data, dat[['tsne']]@cell.embeddings)
for(metric in qc_metric) {
  qc_tsne[[metric]] <- tmp %>%
    ggplot(mapping = aes_string(x = 'tSNE_1', y = 'tSNE_2')) +
    geom_point(mapping = aes_string(color = metric)) +
    scale_color_viridis_c() +
    theme(axis.line = element_line(size = 0.5),
          axis.ticks = element_blank(), 
          axis.text = element_blank(),
          axis.title = element_text(size = 10), 
          panel.border = element_rect(color = 'black', fill = NA),
          legend.title = element_blank()) +
    labs(title = metric) +
    guides(color = guide_colorbar(barwidth = 1, 
                                 frame.colour = 'black', 
                                 frame.linewidth = 1, 
                                 ticks.colour = 'black', 
                                 ticks.linewidth = 1))
}
qc_tsne <- cowplot::plot_grid(plotlist = qc_tsne, ncol = round(sqrt(length(qc_metric))))
qc_tsne
ggsave(filename = paste0(results_outpath, 'preliminary_clustering_QC_tsne_adaptiveThresholds.tiff'), plot = qc_tsne, device = 'tiff', height = 9, width = 10.75)
```

From these data, we observe that quality control metrics drive a significant portion of the clustering results. Specifically, cells that would be considered low quality cluster together and comprise clusters 0 and 1. Moving forward, we apply a flat QC threshold for library size and percent.mt based. These threshold values are based on previous scSeq studies.  

--------------------------------------------------------------------------------

### QC refilter (using stricter thresholds)

```{r computer_qc_threshold2, results='hold', fig.width=10, fig.height=5.5}
umi_lo_threshold <- 1e3
log_umi_hi_threshold <- median(dat$log10_total_counts) + 3*mad(x = dat$log10_total_counts, constant = 1)
percent_mt_threshold <- 25

dat <- dat_full
tmp <- dat$nCount_RNA < umi_lo_threshold | dat$log10_total_counts > log_umi_hi_threshold | dat$percent.mt > percent_mt_threshold
dat$outlier <- tmp

# Plot the outlier cells in violin
qc_metrics_plot <- dat@meta.data %>%
  reshape2::melt(id.vars = c('orig.ident','outlier')) %>%
  ggplot(mapping = aes(x = orig.ident, y = value)) +
  geom_violin(scale = 'width') +
  ggbeeswarm::geom_quasirandom(mapping = aes(color = ifelse(outlier, 'True','False')), size = 0.35) +
  scale_color_manual(values = c('True' = 'red', 'False' = 'black')) +
  facet_wrap(. ~ variable, scales = 'free_y') +
  labs(title = 'Quality control metrics') +
  theme(axis.title = element_blank(),
        plot.title = element_text(size = 18, face = 'bold'),
        axis.line.y = element_line(size = 1),
        axis.ticks.y = element_line(size = 1),
        legend.key = element_rect(fill = NA),
        legend.position = 'bottom') +
  guides(color = guide_legend(title = 'Is outlier?'))
tiff(filename = paste0(results_outpath,  'qc_metrics_flatThresholds.tiff'), height = 1500, width = 3000, res = 220)
qc_metrics_plot
dev.off()
```

```{r filter_cells2}
dat <- dat[,dat$outlier == FALSE]
```

-------------------------------------------------------------------------------

We repeat the basic cluster analysis. This is in order to rule out that technical variation is not a driving source of clustering.  

```{r basic_cluster2, echo=TRUE, results='hide', fig.width=6.5}
firstup <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  return(x)
}
cc_genes <- firstup(tolower(readLines(con = cc_genes_path)))
s.genes <- intersect(cc_genes[1:43], rownames(dat))
g2m.genes <- intersect(cc_genes[44:97], rownames(dat))
dat <- dat %>%
  NormalizeData() %>%
  FindVariableFeatures() %>%
  CellCycleScoring(s.features = s.genes, g2m.features = g2m.genes)
dat$CC.difference <- dat$S.Score - dat$G2M.Score
dat <- dat %>%
  ScaleData(vars.to.regress = 'CC.difference') %>%
  RunPCA(npcs = 40) %>%
# ElbowPlot(dat, ndims = 40)
  FindNeighbors(dims = 1:15) %>%
  RunTSNE(dims = 1:15) %>%
  FindClusters()
dat$orig.ident <- factor(dat$orig.ident, levels = c('SCtrl','S1d','S7d'))
# DimPlot(dat, label = TRUE, group.by = 'orig.ident')
```


```{r qc_tsne2, fig.height=6, fig.width=7}
qc_metric <- c('log10_total_features_by_counts',
               'log10_total_counts',
               'pct_counts_in_top_200_features',
               'percent.mt')
qc_tsne <- vector(mode = 'list', length = length(qc_metric))
names(qc_tsne) <- qc_metric
tmp <- cbind(dat@meta.data, dat[['tsne']]@cell.embeddings)
for(metric in qc_metric) {
  qc_tsne[[metric]] <- tmp %>%
    ggplot(mapping = aes_string(x = 'tSNE_1', y = 'tSNE_2')) +
    geom_point(mapping = aes_string(color = metric)) +
    scale_color_viridis_c() +
    theme(axis.line = element_line(size = 0.5),
          axis.ticks = element_blank(), 
          axis.text = element_blank(),
          axis.title = element_text(size = 10), 
          panel.border = element_rect(color = 'black', fill = NA),
          legend.title = element_blank()) +
    labs(title = metric) +
    guides(color = guide_colorbar(barwidth = 1, 
                                 frame.colour = 'black', 
                                 frame.linewidth = 1, 
                                 ticks.colour = 'black', 
                                 ticks.linewidth = 1))
}
qc_tsne <- cowplot::plot_grid(plotlist = qc_tsne, ncol = round(sqrt(length(qc_metric))))
qc_tsne
ggsave(filename = paste0(results_outpath, 'preliminary_clustering_QC_tsne_flatThresholds.tiff'), plot = qc_tsne, device = 'tiff', height = 6, width = 7)
```

--------------------------------------------------------------------------------

### Dimensional Reduction

```{r compute_pca_dims, fig.width=7, fig.height=8, results='hide'}
plot1 <- ElbowPlot(dat, ndims = 40)
dat <- JackStraw(object = dat, reduction = 'pca', dims = 40)
dat <- ScoreJackStraw(object = dat, reduction = 'pca', dims = 1:40)
plot2 <- JackStrawPlot(object = dat, dims = 1:20)
plot <- cowplot::plot_grid(plot1, plot2, ncol = 1, rel_heights = c(0.5,1))
plot
ggsave(filename = paste0(results_outpath, 'PCA.tiff'), plot = plot, device = 'tiff', height = 8, width = 7)
```


```{r pca_biplot_cluster, fig.height=14, fig.width=14.5, results='hide'}
npcs <- which(dat@reductions$pca@jackstraw$overall.p.values[,2] < 1e-10)
npcs <- 1:11
total_var <- sum(matrixStats::rowVars(x = dat[['RNA']]@scale.data))
pc_ev <- dat[['pca']]@stdev^2
explained_var <- round(pc_ev/total_var * 100, digits = 1)

color_by <- 'orig.ident'
tmp <- cbind(dat[['pca']]@cell.embeddings, dat@meta.data)
tmp_plots <- vector(mode = 'list', length = length(npcs))
for(i in 1:(length(npcs)-1)) {
  tmp_plots[[i]] <- vector(mode = 'list', length = length(npcs))
  for(j in (i+1):length(npcs)) {
    dim_i <- paste0('PC_', npcs[i])
    dim_j <- paste0('PC_', npcs[j])
    tmp_plots[[i]][[j]] <- tmp %>%
      ggplot(mapping = aes_string(y = dim_i, x = dim_j)) +
      geom_point(mapping = aes_string(color = color_by), size = 1) +
      geom_hline(yintercept = 0, linetype = 'dashed') +
      geom_vline(xintercept = 0, linetype = 'dashed') +
      theme(panel.background = element_rect(fill = NA, color = 'black'),
            panel.grid = element_blank(),
            axis.title = element_blank(),
            axis.text = element_blank(),
            axis.ticks = element_blank(),
            legend.position = 'none')
  }
  tmp_plots[[i]][[i]] <- cowplot::ggdraw() + cowplot::draw_label(x = 0.5, y = 0.5, paste0(dim_i, '\n', explained_var[npcs[i]]))
  tmp_plots[[i]] <- cowplot::plot_grid(plotlist = tmp_plots[[i]], ncol = length(tmp_plots[[i]]))
}
# tmp_plots[[length(npcs)]] <- vector(mode = 'list', length = length(npcs) + 1)
tmp_plots[[length(npcs)]][[length(npcs)]] <- cowplot::ggdraw() + cowplot::draw_label(x = 0.5, y = 0.5, paste0('PC_', npcs[length(npcs)], '\n', explained_var[npcs[length(npcs)]]))
tmp_plots[[length(npcs)]] <- cowplot::plot_grid(plotlist = tmp_plots[[length(npcs)]], ncol = length(tmp_plots[[length(npcs)]]))
tmp_plots <- cowplot::plot_grid(plotlist = tmp_plots, ncol = 1)
tmp <- tmp %>%
      ggplot(mapping = aes_string(x = dim_i, y = dim_j)) +
      geom_point(mapping = aes_string(color = color_by), size = 1) +
      geom_hline(yintercept = 0, linetype = 'dashed') +
      geom_vline(xintercept = 0, linetype = 'dashed') +
      theme(panel.background = element_rect(fill = NA, color = 'black'),
            panel.grid = element_blank(),
            axis.title = element_blank(),
            axis.text = element_blank(),
            axis.ticks = element_blank(),
            legend.key = element_rect(color = NA, fill = NA)) +
  guides(color = guide_legend(title = 'Cluster', override.aes = list(size = 4)))
tmp_legend <- cowplot::get_legend(tmp)
tmp_plots <- cowplot::plot_grid(tmp_plots, tmp_legend, rel_widths = c(1, 0.05))
tmp_plots
ggsave(filename = paste0(results_outpath, 'PCA_biplot.tiff'), plot = tmp_plots, height = 14, width = 14.5)
```


```{r compute_knn_k, results='hide', eval=FALSE}
# distance matrix in PCA-space
dat_dist <- dist(x = dat[['pca']]@cell.embeddings[,npcs])

# Assign values of k.param to iterate
k_range <- seq(from = 5, to = 35, by = 5) # sqrt(ncol(dat)) == 25.6907
names(k_range) <- paste('k', k_range, sep ='_')
k_results <- vector(mode = 'list', length = length(k_range))
names(k_results) <- names(k_range)

# Cluster data through k.params using a set louvain resolution
for(k in 1:length(k_range)) {
  tmp <- FindNeighbors(object = dat, k.param = k_range[k], dims = npcs)
  tmp <- FindClusters(tmp, resolution = 0.8, algorithm = 3)
  k_results[[names(k_range)[k]]] <- tmp@active.ident
}
k_results <- do.call(cbind, k_results)

# Compute silhouette coefficients for clustering results
silhouette_val <- vector(mode = 'list', length = ncol(k_results))
names(silhouette_val) <- colnames(k_results)
for(k in 1:ncol(k_results)) {
  silhouette_val[[colnames(k_results)[k]]] <- cluster::silhouette(x = k_results[,k], dist = dat_dist)
}

# Plot silhouette coefficients
tiff(filename = paste0(results_outpath, 'SilhouettePlots_kparamTesting.tiff'), height = 2400, width = 2440, res = 220)
plot_dim <- ceiling(sqrt(length(silhouette_val)))
{
  par(mfrow = c(plot_dim, plot_dim))
  for(k in 1:length(silhouette_val)) {
    cat(plot(silhouette_val[[k]], border = NA, main = paste(names(silhouette_val)[k], '; res = 0.8'), cex = 1.5))
  }
}
dev.off()
```

```{r set_knn_k}
dat <- FindNeighbors(object = dat, dims = npcs, k.param = 20)
```


Now iterate through various louvain resolutions.  

```{r compute_louvain_resolution, results='hide', eval=FALSE}
# distance matrix in PCA-space
dat_dist <- dist(x = dat[['pca']]@cell.embeddings[,npcs])

res_range <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
names(res_range) <- paste('res', res_range, sep ='_')
res_results <- vector(mode = 'list', length = length(res_range))
names(res_results) <- names(res_range)

# Cluster data through k.params using a set louvain resolution
for(r in 1:length(res_range)) {
  tmp <- FindClusters(dat, resolution = res_range[r], algorithm = 3)
  res_results[[names(res_range)[r]]] <- tmp@active.ident
}
res_results <- do.call(cbind, res_results)

# Compute silhouette coefficients for clustering results
silhouette_val <- vector(mode = 'list', length = ncol(res_results))
names(silhouette_val) <- colnames(res_results)
for(r in 1:ncol(res_results)) {
  silhouette_val[[colnames(res_results)[r]]] <- cluster::silhouette(x = res_results[,r], dist = dat_dist)
}

# Plot silhouette coefficients
tiff(filename = paste0(results_outpath, 'SilhouettePlots_resTesting.tiff'), height = 2400, width = 2440, res = 220)
plot_dim <- ceiling(sqrt(length(silhouette_val)))
{
  par(mfrow = c(ceiling(length(res_range)/plot_dim), plot_dim))
  for(r in 1:length(silhouette_val)) {
    cat(plot(silhouette_val[[r]], border = NA, main = paste('k.param = 20;', names(silhouette_val)[r]), cex = 1.5))
  }
}
dev.off()
```

```{r set_graph_resolution, results='hide'}
dat <- FindNeighbors(object = dat, dims = npcs, k.param = 20)
dat <- FindClusters(object = dat, resolution = 0.8)
dat <- RunTSNE(object = dat)
```

```{r graph_clustering_tsne, fig.width=11, fig.height=4.5}
plot1 <- DimPlot(dat, group.by = 'orig.ident', reduction = 'tsne', pt.size = 2) + 
  theme(axis.line = element_line(size = 0.5),
        axis.ticks = element_blank(), 
        axis.text = element_blank(), 
        axis.title = element_text(size = 10), 
        panel.border = element_rect(color = 'black', fill = NA))
plot2 <- DimPlot(dat, group.by = 'seurat_clusters', label = TRUE, label.size = 6, reduction = 'tsne', pt.size = 2) + 
  theme(axis.line = element_line(size = 0.5),
        axis.ticks = element_blank(), 
        axis.text = element_blank(),
        axis.title = element_text(size = 10), 
        panel.border = element_rect(color = 'black', fill = NA))
plot <- cowplot::plot_grid(plot1, plot2, ncol = 2, rel_widths = c(1,0.925))
plot
ggsave(filename = paste0(results_outpath, 'SVZ_tsne.tiff'), plot = plot, device = 'tiff', height = 4.5, width = 11)
```


--------------------------------------------------------------------------------

### Cluster DE genes

```{r graph_DE_markers, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
markers <- FindAllMarkers(object = dat, assay = 'RNA', slot = 'data', test.use = 'wilcox', only.pos = TRUE)
saveRDS(object = markers, file = paste0(results_outpath, 'graph_de_markers.rds'))
write.csv(file = paste0(results_outpath, 'graph_de_markers.csv'), x= markers[markers$p_val_adj < 0.001,], quote = FALSE)
```

These are globally DE genes i.e. each cluster vs all other cells combined. DE is calculated using a Wilcoxon Rank sum test, which is a conservative approach (low false-positives but high false-negatives).  

```{r cluster_markers_table, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
markers <- readRDS(file = paste0(results_outpath, 'graph_de_markers.rds'))
markers <- markers[markers$p_val_adj < 0.001, c(6,7,2,5,1,3,4)]
markers[c('p_val_adj','avg_logFC','p_val','pct.1','pct.2')] <- signif(markers[c('p_val_adj','avg_logFC','p_val','pct.1','pct.2')]
, digits = 3)
DT::datatable(data = markers, rownames = FALSE, extensions = c('Scroller','Buttons'), options = list(scroller = TRUE, deferRender = TRUE, scrollY = 350, fixedColumns = TRUE, autoWidth = TRUE, pageLength = 10, dom = 'Bfrtip', buttons = list(extend = 'collection', buttons = c('csv', 'excel', 'pdf'))))
```

```{r DEgenes_scHeatmap, fig.align='center', fig.height=5, fig.width=10}
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
dat.cols <- gg_color_hue(n = length(levels(dat$seurat_clusters)))

marker.genes <- markers %>% filter(!grepl(pattern = 'Gm', x = gene)) %>% filter(pct.1 > 0.25) %>%  group_by(cluster) %>% top_n(n = 50, wt = -p_val_adj) %>% .[['gene']] %>% unique()
# marker.genes <- VariableFeatures(dat)
tmp_fetch <- FetchData(object = dat, vars = c('seurat_clusters', marker.genes), slot = 'data') %>%
  tibble::rownames_to_column(var = 'barcode') %>%
  arrange(seurat_clusters)
tmp_annotation <- data.frame('seurat_clusters'= tmp_fetch['seurat_clusters'])
rownames(tmp_annotation) <- tmp_fetch[['barcode']]
tmp <- t(as.matrix(tmp_fetch[sapply(X = tmp_fetch, FUN = is.numeric)]))
colnames(tmp) <- tmp_fetch[['barcode']]
tmp_annotation_color <- dat.cols
names(tmp_annotation_color) <- levels(dat$seurat_clusters)
tmp_annotation_color <- list('seurat_clusters' = tmp_annotation_color)

min.val <- min(tmp)
max.val <- -min.val

paletteLength <- 100
myColor <- rev(colorRampPalette(RColorBrewer::brewer.pal(n = 9, name = 'Spectral'))(paletteLength))
myBreaks <- c(seq(from = min.val, to = 0, length.out =  ceiling(paletteLength/2) + 1),
              seq(from = max.val/paletteLength, to = max.val, length.out = floor(paletteLength/2)))

heatmap <- pheatmap::pheatmap(
  mat = tmp,
  annotation_col = tmp_annotation,
  annotation_colors = tmp_annotation_color,
  silent = TRUE,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  # color = myColor,
  color = viridis::viridis_pal(option = 'A')(100),
  # breaks = myBreaks,
  show_colnames = FALSE,
  show_rownames = FALSE,
  fontsize = 12,
  # annotation_legend = FALSE,
  annotation_names_col = FALSE,
) %>%
  ggplotify::as.ggplot() +
  theme(legend.position = 'none')
heatmap
ggsave(filename = paste0(results_outpath, 'graph_DEgenes_heatmap.tiff'), plot = heatmap, device = 'tiff', height = 5, width = 10)
```


Heatmap of the top 10 DE genes for each cluster.  

```{r cluster_markers_heatmap, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, fig.width=4, fig.height=11, fig.align='center'}
markers <- readRDS(file = paste0(results_outpath, 'graph_de_markers.rds'))
ngenes <- 10
marker.genes <- c()
for(c in levels(markers$cluster)) {
  tmp_results <- markers[markers$cluster == c & markers$p_val_adj < 1e-03,]
  tmp_genes <- tmp_results[order(tmp_results$avg_logFC, decreasing = TRUE),]$gene
  genes_index <- which(!(tmp_genes %in% marker.genes))[1:ngenes]
  marker.genes <- c(marker.genes, tmp_genes[genes_index])
}
names(marker.genes) <- rep(levels(markers$cluster), each = ngenes)

Idents(dat) <- 'seurat_clusters'
DefaultAssay(dat) <- 'RNA'
tmp <- ScaleData(dat, features = marker.genes)
avg.exp <- FetchData(tmp, vars = c('seurat_clusters', marker.genes), slot = 'scale.data') %>%
  reshape2::melt(id.vars = c('seurat_clusters')) %>%
  group_by(seurat_clusters, variable) %>%
  summarise(avg.exp = mean(value))

for(c in levels(markers$cluster)) {
  tmp <- avg.exp[avg.exp$seurat_clusters == c & avg.exp$variable %in% marker.genes[names(marker.genes) == c],]
  tmp <- tmp[order(tmp$avg.exp, decreasing = TRUE),]$variable
  marker.genes[names(marker.genes) == c] <- as.character(tmp)
}
avg.exp <- avg.exp %>% mutate(variable = factor(variable, levels = rev(marker.genes)))

paletteLength <- 200
max.z <- 2
myColor <- rev(colorRampPalette(RColorBrewer::brewer.pal(n = 9, name = 'RdBu'))(paletteLength))
myBreaks <- c(seq(min(avg.exp$avg.exp), 0, length.out=ceiling(paletteLength/2) + 1),
              seq(min(max.z, max(avg.exp$avg.exp))/paletteLength, min(max.z, max(avg.exp$avg.exp)), length.out=floor(paletteLength/2)))
marker.heatmap <- avg.exp %>%
  ggplot(mapping = aes(x = seurat_clusters, y = variable, fill = avg.exp)) +
  geom_tile(color = 'black', size = 0.25) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_gradientn(colors = myColor,
                     values = scales::rescale(x = myBreaks, to = c(0,1)),
                      limits = c(NA, max.z), na.value = myColor[paletteLength], breaks = seq(-5,5,0.5)) +
  # scale_fill_viridis_c() +
  theme(axis.text.x = element_text(size = 12),
        axis.title = element_blank()) +
  guides(fill = guide_colorbar(title = 'Expression\nz-score', barwidth = 1.25, frame.colour = 'black', frame.linewidth = 1, ticks.colour = 'black', ticks.linewidth = 1))

marker.heatmap
ggsave(filename = paste0(results_outpath, 'graph_cluster_markers_heatmap.tiff'), plot = marker.heatmap, device = 'tiff', height = 9, width = 4)
```

### Marker gene tSNEs

Some genes related to myeloid cells and damage-associated microglia (DAMs).  

```{r myeloid_gene_tsne, fig.align='center', fig.width=14, fig.height=10}
some_markers <- c('P2ry12','Tmem119','Cx3cr1','Csf1r','Adgre1','Ptprc','Ly6c2','Ccr2','Spp1','Apoe','Trem2','Tyrobp','Ms4a7','Lyve1','Mrc1','Ldha','Cd68','Cd63','Mki67','Top2a')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- FeaturePlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 1.5)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            max.exp <- ceiling(max(tmp_plot[[x]]$data[[4]])*10)/10
                            tmp_plot[[x]] + 
                              geom_text(mapping = aes(x = -7.5, y = 17.5, label = names(tmp_plot)[x]),
                                        fontface = 'italic',
                                        size = 4.5,
                                        hjust = 1) +
                              theme(plot.title = element_blank(), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.text = element_blank(), 
                                    axis.title = element_blank(), 
                                    axis.ticks = element_blank(), 
                                    legend.key = element_rect(fill = NA),
                                    legend.text = element_text(size = 10),
                                    legend.position = c(0.8, 0.175), 
                                    legend.key.size = unit(0.25, units = 'cm'), 
                                    legend.spacing.x = unit(0.1, units = 'cm')) +
                              # scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11,'Spectral')),
                              #                       breaks = c(0, max.exp),
                              #                       limits = c(0, max.exp)) + 
                              scale_color_gradient2(mid = 'grey80', 
                                                    high = 'red3', 
                                                    breaks = c(0, max.exp),
                                                    limits = c(0, max.exp)) +
                              guides(color = guide_colorbar(barwidth = 0.5, 
                                                            frame.colour = 'black', 
                                                            frame.linewidth = 1,
                                                            ticks.colour = 'black',
                                                            ticks.linewidth = 1,
                                                            barheight = 2
                                                            )
                                     )
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 5)
extended_plots
ggsave(filename = paste0(results_outpath, 'myeloid_genes_tsne.tiff'), plot = extended_plots, device = 'tiff', height = 10, width = 14)
```


Some genes related to quiescent NSCs (qNSCs).  

```{r qNSC_gene_tsne, fig.align='center', fig.width=16.8, fig.height=12.5}
some_markers <- c('Aldoc','Aqp4','Atp1a2','Bcan','Cldn10','Clu','Fgfr3','Gja1','Gpr37l1','Htra1','Prdx6','Prnp','Ptn','Slc1a2','Slc1a3','Slc6a1','Sparcl1','Tspan7','Id2','Id3','Id4','Sox9','Aldh1l1','Fabp7','Fasn','Hes5','Nr2e1','Notch2')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- FeaturePlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 1.5)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            max.exp <- ceiling(max(tmp_plot[[x]]$data[[4]])*10)/10
                            tmp_plot[[x]] + 
                              geom_text(mapping = aes(x = -7.5, y = 17.5, label = names(tmp_plot)[x]),
                                        fontface = 'italic',
                                        size = 4.5,
                                        hjust = 1) +
                              theme(plot.title = element_blank(), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.text = element_blank(), 
                                    axis.title = element_blank(), 
                                    axis.ticks = element_blank(), 
                                    legend.key = element_rect(fill = NA),
                                    legend.text = element_text(size = 10),
                                    legend.position = c(0.8, 0.175), 
                                    legend.key.size = unit(0.25, units = 'cm'), 
                                    legend.spacing.x = unit(0.1, units = 'cm')) +
                              # scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11,'Spectral')),
                              #                       breaks = c(0, max.exp),
                              #                       limits = c(0, max.exp)) + 
                              scale_color_gradient2(mid = 'grey80', 
                                                    high = 'red3', 
                                                    breaks = c(0, max.exp),
                                                    limits = c(0, max.exp)) +
                              guides(color = guide_colorbar(barwidth = 0.5, 
                                                            frame.colour = 'black', 
                                                            frame.linewidth = 1,
                                                            ticks.colour = 'black',
                                                            ticks.linewidth = 1,
                                                            barheight = 1.75
                                                            )
                                     )
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 6)
extended_plots
ggsave(filename = paste0(results_outpath, 'qNSC_genes_tsne.tiff'), plot = extended_plots, device = 'tiff', height = 12.5, width = 16.8)
```


Some genes related to primed NSCs.  

```{r primedNSC_gene_tsne, fig.align='center', fig.width=14, fig.height=7.5}
some_markers <- c('Cpe','Cst3','Dbi','Dkk3','Fxyd1','Gstm1','Igfbp5','Itm2b','Mt1','Ntrk2','Prdx6','S100a6','Thbs4')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- FeaturePlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 1.5)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            max.exp <- ceiling(max(tmp_plot[[x]]$data[[4]])*10)/10
                            tmp_plot[[x]] + 
                              geom_text(mapping = aes(x = -7.5, y = 17.5, label = names(tmp_plot)[x]),
                                        fontface = 'italic',
                                        size = 4.5,
                                        hjust = 1) +
                              theme(plot.title = element_blank(), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.text = element_blank(), 
                                    axis.title = element_blank(), 
                                    axis.ticks = element_blank(), 
                                    legend.key = element_rect(fill = NA),
                                    legend.text = element_text(size = 10),
                                    legend.position = c(0.8, 0.175), 
                                    legend.key.size = unit(0.25, units = 'cm'), 
                                    legend.spacing.x = unit(0.1, units = 'cm')) +
                              # scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11,'Spectral')),
                              #                       breaks = c(0, max.exp),
                              #                       limits = c(0, max.exp)) + 
                              scale_color_gradient2(mid = 'grey80', 
                                                    high = 'red3', 
                                                    breaks = c(0, max.exp),
                                                    limits = c(0, max.exp)) +
                              guides(color = guide_colorbar(barwidth = 0.5, 
                                                            frame.colour = 'black', 
                                                            frame.linewidth = 1,
                                                            ticks.colour = 'black',
                                                            ticks.linewidth = 1,
                                                            barheight = 1.75
                                                            )
                                     )
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 5)
extended_plots
ggsave(filename = paste0(results_outpath, 'primedNSC_genes_tsne.tiff'), plot = extended_plots, device = 'tiff', height = 7.5, width = 14)
```


Some genes related to activated NSCs (aNSCs).  

```{r aNSC_gene_tsne, fig.align='center', fig.width=16.8, fig.height=17.5}
some_markers <- c('Acot1', 'Ascl1', 'Ckb', 'Eef1a1', 'Egfr', 'Lima1', 'Luc7l3', 'Miat', 'Mycn', 'Npm1', 'Olig2', 'Pabpc1', 'Ptma', 'Rpl12', 'Rpl41', 'Rpsa', 'Dll1', 'Dll3', 'Fos', 'Ccnd1', 'E2f1', 'Foxm1', 'Myc', 'Cdk2', 'Ldhb', 'Aurkb', 'Dcx', 'Gad1', 'Mki67', 'Sp8', 'Jag1', 'Ntsr2', 'Rpl32', 'Ccna2', 'Ccnd2', 'Pax6', 'Cdk1', 'Dlx1', 'Dlx2')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- FeaturePlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 1.5)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            max.exp <- ceiling(max(tmp_plot[[x]]$data[[4]])*10)/10
                            tmp_plot[[x]] + 
                              geom_text(mapping = aes(x = -7.5, y = 17.5, label = names(tmp_plot)[x]),
                                        fontface = 'italic',
                                        size = 4.5,
                                        hjust = 1) +
                              theme(plot.title = element_blank(), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.text = element_blank(), 
                                    axis.title = element_blank(), 
                                    axis.ticks = element_blank(), 
                                    legend.key = element_rect(fill = NA),
                                    legend.text = element_text(size = 10),
                                    legend.position = c(0.8, 0.175), 
                                    legend.key.size = unit(0.25, units = 'cm'), 
                                    legend.spacing.x = unit(0.1, units = 'cm')) +
                              # scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11,'Spectral')),
                              #                       breaks = c(0, max.exp),
                              #                       limits = c(0, max.exp)) + 
                              scale_color_gradient2(mid = 'grey80', 
                                                    high = 'red3', 
                                                    breaks = c(0, max.exp),
                                                    limits = c(0, max.exp)) +
                              guides(color = guide_colorbar(barwidth = 0.5, 
                                                            frame.colour = 'black', 
                                                            frame.linewidth = 1,
                                                            ticks.colour = 'black',
                                                            ticks.linewidth = 1,
                                                            barheight = 1.75
                                                            )
                                     )
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 6)
extended_plots
ggsave(filename = paste0(results_outpath, 'aNSC_genes_tsne.tiff'), plot = extended_plots, device = 'tiff', height = 17.5, width = 16.8)
```



### Marker gene Violin plots

Some genes related to myeloid cells and damage-associated microglia (DAMs).  

```{r myeloid_gene_vln, fig.align='center', fig.width=12, fig.height=12.25}
some_markers <- c('P2ry12','Tmem119','Cx3cr1','Csf1r','Adgre1','Ptprc','Ly6c2','Ccr2','Spp1','Apoe','Trem2','Tyrobp','Ms4a7','Lyve1','Mrc1','Ldha','Cd68','Cd63','Mki67','Top2a')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- VlnPlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 0)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            tmp_plot[[x]] + 
                              labs(label = names(tmp_plot)[x]) +
                              ggbeeswarm::geom_quasirandom(mapping = aes_string(x = 'ident',
                                                                                y = names(tmp_plot)[x]), 
                                                           size = 0.5) +
                              theme(plot.title = element_text(hjust = 0, size = 14), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.title = element_blank(),
                                    axis.ticks.x = element_blank(),
                                    axis.text.x = element_text(size = 12, angle = 0, face = 'bold'),
                                    axis.text.y = element_text(size = 10),
                                    legend.position = 'none')
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 3)
extended_plots
ggsave(filename = paste0(results_outpath, 'myeloid_genes_vln.tiff'), plot = extended_plots, device = 'tiff', height = 12, width = 12.25)
```


Some genes related to quiescent NSCs (qNSCs).  

```{r qNSC_gene_tsne, fig.align='center', fig.width=12, fig.height=17.5}
some_markers <- c('Aldoc','Aqp4','Atp1a2','Bcan','Cldn10','Clu','Fgfr3','Gja1','Gpr37l1','Htra1','Prdx6','Prnp','Ptn','Slc1a2','Slc1a3','Slc6a1','Sparcl1','Tspan7','Id2','Id3','Id4','Sox9','Aldh1l1','Fabp7','Fasn','Hes5','Nr2e1','Notch2')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- VlnPlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 0)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            tmp_plot[[x]] + 
                              labs(label = names(tmp_plot)[x]) +
                              ggbeeswarm::geom_quasirandom(mapping = aes_string(x = 'ident',
                                                                                y = names(tmp_plot)[x]), 
                                                           size = 0.5) +
                              theme(plot.title = element_text(hjust = 0, size = 14), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.title = element_blank(),
                                    axis.ticks.x = element_blank(),
                                    axis.text.x = element_text(size = 12, angle = 0, face = 'bold'),
                                    axis.text.y = element_text(size = 10),
                                    legend.position = 'none')
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 3)
extended_plots
ggsave(filename = paste0(results_outpath, 'qNSC_genes_vln.tiff'), plot = extended_plots, device = 'tiff', height = 17.5, width = 12)
```


Some genes related to primed NSCs.  

```{r primedNSC_gene_tsne, fig.align='center', fig.width=12, fig.height=7.5}
some_markers <- c('Cpe','Cst3','Dbi','Dkk3','Fxyd1','Gstm1','Igfbp5','Itm2b','Mt1','Ntrk2','Prdx6','S100a6','Thbs4')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- VlnPlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 0)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            tmp_plot[[x]] + 
                              labs(label = names(tmp_plot)[x]) +
                              ggbeeswarm::geom_quasirandom(mapping = aes_string(x = 'ident',
                                                                                y = names(tmp_plot)[x]), 
                                                           size = 0.5) +
                              theme(plot.title = element_text(hjust = 0, size = 14), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.title = element_blank(),
                                    axis.ticks.x = element_blank(),
                                    axis.text.x = element_text(size = 12, angle = 0, face = 'bold'),
                                    axis.text.y = element_text(size = 10),
                                    legend.position = 'none')
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 3)
extended_plots
ggsave(filename = paste0(results_outpath, 'primedNSC_genes_vln.tiff'), plot = extended_plots, device = 'tiff', height = 8.75, width = 12)
```


Some genes related to activated NSCs (aNSCs).  

```{r aNSC_gene_tsne, fig.align='center', fig.width=12, fig.height=22.275}
some_markers <- c('Acot1', 'Ascl1', 'Ckb', 'Eef1a1', 'Egfr', 'Lima1', 'Luc7l3', 'Miat', 'Mycn', 'Npm1', 'Olig2', 'Pabpc1', 'Ptma', 'Rpl12', 'Rpl41', 'Rpsa', 'Dll1', 'Dll3', 'Fos', 'Ccnd1', 'E2f1', 'Foxm1', 'Myc', 'Cdk2', 'Ldhb', 'Aurkb', 'Dcx', 'Gad1', 'Mki67', 'Sp8', 'Jag1', 'Ntsr2', 'Rpl32', 'Ccna2', 'Ccnd2', 'Pax6', 'Cdk1', 'Dlx1', 'Dlx2')
DefaultAssay(dat) <- 'RNA'
Idents(dat) <- 'seurat_clusters'
extended_plots <- VlnPlot(object = dat, features = some_markers, slot = 'data', combine = FALSE, pt.size = 0)
names(extended_plots) <- some_markers
extended_plots <- lapply(X = seq_along(extended_plots), 
                          tmp_plot = extended_plots,
                          FUN = function(x, tmp_plot) {
                            tmp_plot[[x]] + 
                              labs(label = names(tmp_plot)[x]) +
                              ggbeeswarm::geom_quasirandom(mapping = aes_string(x = 'ident',
                                                                                y = names(tmp_plot)[x]), 
                                                           size = 0.5) +
                              theme(plot.title = element_text(hjust = 0, size = 14), 
                                    panel.border = element_rect(fill = NA, color = 'black'), 
                                    panel.background = element_rect(fill = NA), 
                                    axis.title = element_blank(),
                                    axis.ticks.x = element_blank(),
                                    axis.text.x = element_text(size = 12, angle = 0, face = 'bold'),
                                    axis.text.y = element_text(size = 10),
                                    legend.position = 'none')
                            }
                          )
extended_plots <- cowplot::plot_grid(plotlist = extended_plots, ncol = 3)
extended_plots
ggsave(filename = paste0(results_outpath, 'aNSC_genes_umaps.tiff'), plot = extended_plots, device = 'tiff', height = 22.275, width = 12)
```



### Cluster Dendrograms

```{r dendrogram_subcluster, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, fig.align='center', fig.width=4, fig.height=4}
Idents(dat) <- 'seurat_clusters' 
avg <- AverageExpression(object = dat, assays = 'RNA', slot = 'scale.data')[[1]]
dat.dist <- dist(x = t(avg))
dat.tree <- hclust(d = dat.dist, method = 'ward.D2')
dat.dend <- dendsort::dendsort(as.dendrogram(dat.tree, hang = 0.1))
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
dat.cols <- gg_color_hue(n = length(levels(dat$seurat_clusters)))
dendextend::labels_colors(dat.dend) <- dat.cols[dat.tree$labels][order.dendrogram(dat.dend)]
dendextend::labels_colors(dat.dend) <- dat.cols
dendextend::labels_cex(dat.dend) <- 0.75
tiff(filename = paste0(results_outpath, 'Cluster_dendrogram.tiff'), height = 630, width = 630)
{par(mar = c(2,2,2,2), cex = 3, lwd = 2); dendextend::plot_horiz.dendrogram(dat.dend, side = FALSE, main = 'Cluster dendrogram')}
dev.off()
dendextend::plot_horiz.dendrogram(dat.dend, side = FALSE, main = 'Cluster dendrogram')
rm(avg, dat.dist, dat.tree, dat.dend)
```


--------------------------------------------------------------------------------

### Cluster dynamics

Next we explore the population changes for each of the clusters between the 3 conditions. We calculate the absolute numbers of cells per cluster as well as the proportion out of all cells for each condition.  

```{r microglia_population_dynamics, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, fig.align='center', fig.width=8, fig.height=3.75}
counts <- data.frame(table(dat$seurat_clusters, dat$orig.ident))
names(counts) <- c('seurat_clusters','orig.ident','count')
numbers <- counts %>%
  filter(seurat_clusters %in% c(0,1,2,6)) %>%
  ggplot(mapping = aes(x = orig.ident, y = count, group = seurat_clusters)) + 
  geom_bar(aes(fill = seurat_clusters), stat = 'identity', color = 'black', size = 0.75) +
  scale_y_continuous() +
  scale_x_discrete() + 
  ylab('# of cells') + 
  theme(axis.title.x = element_blank(),
        axis.title.y = element_text(size = 12), 
        axis.text.x = element_text(size = 12), 
        axis.line = element_line(size = 1),
        panel.background = element_rect(fill = NA),
        axis.text.y = element_text(size = 12))
props <- counts %>% 
  filter(seurat_clusters %in% c(0,1,2,6)) %>%
  ggplot(mapping = aes(x = orig.ident, y = count, group = seurat_clusters)) + 
  geom_bar(aes(fill = seurat_clusters), stat = 'identity', color = 'black', size = 0.75, position = 'fill') +
  scale_y_continuous() + 
  scale_x_discrete() +
  ylab('% of cells') + 
  theme(axis.title.x = element_blank(), 
        axis.title.y = element_text(size = 12), 
        axis.text.x = element_text(size = 12),
        axis.line = element_line(size = 1), 
        panel.background = element_rect(fill = NA), 
        axis.text.y = element_text(size = 12), 
        legend.title = element_blank(), 
        legend.text = element_text(size = 12))
legend <- cowplot::get_legend(plot = props)
pop.dynamics <- cowplot::plot_grid(numbers + theme(legend.position = 'none'), props + theme(legend.position = 'none'), legend, ncol = 3, rel_widths = c(1, 1, 0.25))

pop.dynamics
ggsave(filename = paste0(results_outpath, 'microglia_population_dynamics.tiff'), plot = pop.dynamics, device = 'tiff', height = 3.75, width = 8)
```

```{r NSC_population_dynamics, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, fig.align='center', fig.width=8, fig.height=3.75}
counts <- data.frame(table(dat$seurat_clusters, dat$orig.ident))
names(counts) <- c('seurat_clusters','orig.ident','count')
numbers <- counts %>%
  filter(seurat_clusters %in% c(3,4, 5)) %>%
  ggplot(mapping = aes(x = orig.ident, y = count, group = seurat_clusters)) + 
  geom_bar(aes(fill = seurat_clusters), stat = 'identity', color = 'black', size = 0.75) +
  scale_y_continuous() +
  scale_x_discrete() + 
  ylab('# of cells') + 
  theme(axis.title.x = element_blank(),
        axis.title.y = element_text(size = 12), 
        axis.text.x = element_text(size = 12), 
        axis.line = element_line(size = 1),
        panel.background = element_rect(fill = NA),
        axis.text.y = element_text(size = 12))
props <- counts %>% 
  filter(seurat_clusters %in% c(3,4,5)) %>%
  ggplot(mapping = aes(x = orig.ident, y = count, group = seurat_clusters)) + 
  geom_bar(aes(fill = seurat_clusters), stat = 'identity', color = 'black', size = 0.75, position = 'fill') +
  scale_y_continuous() + 
  scale_x_discrete() +
  ylab('% of cells') + 
  theme(axis.title.x = element_blank(), 
        axis.title.y = element_text(size = 12), 
        axis.text.x = element_text(size = 12),
        axis.line = element_line(size = 1), 
        panel.background = element_rect(fill = NA), 
        axis.text.y = element_text(size = 12), 
        legend.title = element_blank(), 
        legend.text = element_text(size = 12))
legend <- cowplot::get_legend(plot = props)
pop.dynamics <- cowplot::plot_grid(numbers + theme(legend.position = 'none'), props + theme(legend.position = 'none'), legend, ncol = 3, rel_widths = c(1, 1, 0.25))

pop.dynamics
ggsave(filename = paste0(results_outpath, 'NSC_population_dynamics.tiff'), plot = pop.dynamics, device = 'tiff', height = 3.75, width = 8)
```

--------------------------------------------------------------------------------

```{r filter_LR, eval=TRUE, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
# Import ligand-receptor reference list
lr_ref <- read.csv(file = 'D:/MiamiProject/sci_cellAtlas_scRNAseq/scRNAseq_analysis/ref/fantom_PairsLigRec_mouse_sci.csv', stringsAsFactors = FALSE)
lr_ref <- lr_ref[lr_ref$Pair.Evidence == 'literature supported',] # only those with literature support
lr_ref <- lr_ref[lr_ref$Ligand.ApprovedSymbol %in% rownames(dat[['RNA']]@counts) & 
                   lr_ref$Receptor.ApprovedSymbol %in% rownames(dat[['RNA']]@counts),]
min_pct_threshold <- 0.1

# To calculate scores for a specific set of LR pairs, adjust the following:
# Test only LR pairs where ligand is expressed by a celltype(s)
gene_subset <- 'both'
# gene_subset <- 'both'
# cell_subset <- levels(dat$celltype)
cell_subset <- NULL

tmp_genes <- switch(EXPR = gene_subset, 
                    'Ligand' = unique(lr_ref$Ligand.ApprovedSymbol),
                    'Receptor' = unique(lr_ref$Receptor.ApprovedSymbol),
                    'both' = unique(union(lr_ref$Ligand.ApprovedSymbol, lr_ref$Receptor.ApprovedSymbol)))
Idents(dat) <- 'RNA_snn_res.0.8'
tmp_pct <- FetchData(object = dat, vars = c('seurat_clusters','orig.ident', tmp_genes), slot = 'data') %>%
  group_by(seurat_clusters, orig.ident) %>%
  summarise_at(.vars = tmp_genes, .funs = mean)
if(!is.null(cell_subset)) {
  tmp_pct <- tmp_pct %>% filter(seurat_clusters %in% cell_subset)
}
tmp_genes <- sapply(tmp_pct, FUN = function(xx) any(xx > min_pct_threshold))
lr_ref <- lr_ref[lr_ref$Ligand.ApprovedSymbol %in% names(tmp_genes[tmp_genes]),]
lr_ref <- lr_ref[order(lr_ref$Pair.Name),]
lr_genes <- sort(union(lr_ref$Ligand.ApprovedSymbol, lr_ref$Receptor.ApprovedSymbol))
```

```{r calculate_LR, eval=TRUE, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
# Seurat setup (note: not using celltype_posthoc here)
DefaultAssay(object = dat) <- 'RNA'
Idents(object = dat) <- 'seurat_clusters'

# Extract data
lr_data <- FetchData(object = dat, vars = c('seurat_clusters','orig.ident', lr_genes), slot = 'data')

# Calculate average expression + percent expression matrices per cell/orig.ident
exp_avg <- lr_data %>%
  group_by(seurat_clusters, orig.ident) %>%
  summarise_at(.vars = lr_genes, .funs = mean)
exp_pct <- lr_data %>%
  group_by(seurat_clusters, orig.ident) %>%
  summarise_at(.vars = lr_genes, .funs = function(x) round(mean(x > 0), 3))

# Table of cell counts per orig.ident. Needed for cell permutation sample sizes
cell_counts <- table(dat$seurat_clusters, dat$orig.ident)

# Cell-level expression matrix for genes in LR reference
exp_mat <- as.matrix(FetchData(dat, vars = lr_genes, slot = 'data'))
exp_mat_ligands <- exp_mat[,match(lr_ref[['Ligand.ApprovedSymbol']], colnames(exp_mat))]
exp_mat_receptors <- exp_mat[,match(lr_ref[['Receptor.ApprovedSymbol']], colnames(exp_mat))]

# Determine # of permutations
resample <- 1000

# Data structure for holding results and null distribution score values
var_set <- expand.grid(levels(lr_data$seurat_clusters), levels(lr_data$seurat_clusters), levels(lr_data$orig.ident))
colnames(var_set) <- c('Ligand_cell','Receptor_cell','orig.ident')

# maxT_scores <- matrix(0, nrow = resample, ncol = nrow(lr_ref))
maxT_scores <- vector(mode = 'list', length = nrow(var_set))
# colnames(maxT_scores) <- paste(colnames(exp_mat_ligands), colnames(exp_mat_receptors), sep = '_')
names(maxT_scores) <- paste(var_set$Ligand_cell, var_set$Receptor_cell, var_set$orig.ident, sep = '_')


# calculate null distribution of max-T values
for(i in 1:nrow(var_set)) {
  cellx <- as.character(var_set$Ligand_cell[i]) # these are factors, but cell_counts is sorted by level
  celly <- as.character(var_set$Receptor_cell[i])
  orig.identz <- as.character(var_set$orig.ident[i])
  countx <- cell_counts[cellx, orig.identz]
  county <- cell_counts[celly, orig.identz]
  if(countx == 0 | county == 0) {
    next()
  }
  
   # Randomly select n_c cells (n = #, c = cell-type) 1000 times and extract element positions
  cell_sample <- function(x) {tmp <- rep(0, nrow(exp_mat)); tmp[sample(nrow(exp_mat), size = x, replace = FALSE)] <- 1; return(tmp)}
  index_x <- t(replicate(n = resample, expr = cell_sample(countx)))
  index_y <- t(replicate(n = resample, expr = cell_sample(county)))
  
  # Calculate average expression of all ligands and receptors for the n_c cells
  t <- Sys.time()
  avg_lig <- index_x %*% exp_mat_ligands / countx
  avg_rec <- index_y %*% exp_mat_receptors / county
  print(Sys.time() - t)
  
  # Calculate null LR scores
  scores <- 1/2 * (avg_lig + avg_rec)
  colnames(scores) <- paste(colnames(avg_lig), colnames(avg_rec), sep = '_')
  
  # For max-T method, take element-wise maximum values (this iterates nrow(var_set) times)
  # maxT_scores[scores > maxT_scores] <- scores[scores > maxT_scores]
  maxT_scores[[i]] <- scores
  print(paste("done with", i))
  # print(mean(maxT_scores[,1]))
}

# Calculate average expression matrix
exp_avg <- lr_data %>%
  group_by(seurat_clusters, orig.ident) %>%
  summarise_at(.vars = lr_genes, .funs = mean)
exp_names <- paste(exp_avg[['seurat_clusters']], exp_avg[['orig.ident']], sep = '_')
exp_avg <- exp_avg[,3:ncol(exp_avg)]

# Get indices from expression matrix for ligands/receptors
index_x <- paste(var_set[['Ligand_cell']], var_set[['orig.ident']], sep = '_')
index_x <- match(x = index_x, table = exp_names)
index_y <- paste(var_set[['Receptor_cell']], var_set[['orig.ident']], sep = '_')
index_y <- match(x = index_y, table = exp_names)
index_l <- match(lr_ref[['Ligand.ApprovedSymbol']], colnames(exp_avg))
index_r <- match(lr_ref[['Receptor.ApprovedSymbol']], colnames(exp_avg))
exp_avg_lig <- as.matrix(exp_avg[index_x, index_l])
exp_avg_rec <- as.matrix(exp_avg[index_y, index_r])

# Sanity check - do all column LR pairs match for null maxT matrix and actual expression matrix?
sanity.check <- paste("Do all column LR pairs match?", all(paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_') == colnames(maxT_scores)))
print(sanity.check)

# Calculate LR scores (for data, not nulls)
exp_scores <- 1/2 * (exp_avg_lig + exp_avg_rec)

# Determine which cells do not have at least 10% expression of their gene
exp_pct_filter <- exp_pct[,3:ncol(exp_pct)]
exp_pct_filter_l <- exp_pct_filter[index_x, index_l] < 0.1
exp_pct_filter_r <- exp_pct_filter[index_y, index_r] < 0.1
exp_pct_filter_both <- exp_pct_filter_l | exp_pct_filter_r

# Replace values that don't meet 10% threshold
exp_scores[exp_pct_filter_both] <- NA
rownames(exp_scores) <- paste(var_set[[1]], var_set[[2]], var_set[[3]], sep = '_')
colnames(exp_scores) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')

# Dims of exp_scores are <(cellx * celly * orig.identz), (lig-rec pair)>
# Dims of maxT_scores are <(resampled permutations), (lig-rec pair)>

# Calculate p-values from ecdf using null scores for each LR-pair
pvals <- matrix(NA, nrow = nrow(var_set), ncol = nrow(lr_ref))

# # For maxT:
# # Calculate p-values from ecdf using null scores for each LR-pair
# pvals <- matrix(1, nrow = nrow(var_set), ncol = nrow(lr_ref))
# for(i in 1:ncol(pvals)) {
#   pvals[,i] <- sapply(X = exp_scores[,i], 
#                       nulls = maxT_scores[,i],
#                       FUN = function(x, nulls) {1-ecdf(nulls)(x)})
# }
# colnames(pvals) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')
# rownames(pvals) <- paste(var_set[[1]], var_set[[2]], var_set[[3]], sep = '_')

# For not maxT:
for(i in 1:nrow(pvals)) {
  tmp_nulls <- maxT_scores[[i]]
  tmp_scores <- exp_scores[i,]
  for(j in 1:length(tmp_scores)) {
    if(is.null(tmp_nulls)) {
      next()
    } else {
      pvals[i,j] <- 1-ecdf(tmp_nulls[,j])(tmp_scores[j])
    }
  }
}
colnames(pvals) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')
rownames(pvals) <- paste(var_set[[1]], var_set[[2]], var_set[[3]], sep = '_')

cell_prop <- round(prop.table(cell_counts, margin = 1), 3)*100

# Long-form data.table of results
tmp <- expand.grid(rownames(exp_scores), colnames(exp_scores), stringsAsFactors = FALSE)
tmp_idents <- strsplit(x = tmp[[1]], split = '_')
tmp_pairs <- strsplit(x = tmp[[2]], split = '_')
ligand_cell <- sapply(X = tmp_idents, FUN = `[[`, 1)
receptor_cell <- sapply(X = tmp_idents, FUN = `[[`, 2)
orig.ident <- sapply(X = tmp_idents, FUN = `[[`, 3)
ligand <- sapply(X = tmp_pairs, FUN = `[[`, 1)
receptor <- sapply(X = tmp_pairs, FUN = `[[`, 2)
cell_pair <- paste(ligand_cell, receptor_cell, sep = '_')
lr_pair <- paste(ligand, receptor, sep = '_')
tmp_scores <- exp_scores %>% reshape2::melt() %>% .[[3]]
tmp_avg_l <- c(exp_avg_lig)
tmp_avg_r <- c(exp_avg_rec)
tmp_pvals <- pvals %>% reshape2::melt() %>% .[[3]]
tmp_pct <- exp_pct_filter %>% as.matrix()
tmp_pct_l <- c(tmp_pct[index_x, index_l])
tmp_pct_r <- c(tmp_pct[index_y, index_r])
tmp_count_l <- mapply(FUN = function(x,y) cell_prop[x,y], ligand_cell, orig.ident)
tmp_count_r <- mapply(FUN = function(x,y) cell_prop[x,y], receptor_cell, orig.ident)

# Final result compilation
results <- data.frame('Ligand_cell' = ligand_cell,
                      'Receptor_cell' = receptor_cell,
                      'orig.ident' = orig.ident,
                      'Ligand' = ligand,
                      'Receptor' = receptor,
                      'Score' = tmp_scores,
                      'p_value' = tmp_pvals,
                      'Ligand_avgExp' = tmp_avg_l,
                      'Receptor_avgExp' = tmp_avg_r,
                      'Ligand_pct' = tmp_pct_l,
                      'Receptor_pct' = tmp_pct_r,
                      'Cell_pair' = cell_pair,
                      'LR_pair' = lr_pair,
                      'Ligand_cell_pct' = tmp_count_l,
                      'Receptor_cell_pct' = tmp_count_r,
                      stringsAsFactors = FALSE)

# Save results
saveRDS(object = results, file = paste0(results_outpath, 'LR_results_SVZ.rds'))
write.csv(x = results, file = paste0(results_outpath, 'LigandReceptorAnalysis_SVZ.csv'), row.names = FALSE)


# pval adjustment --------------------------------------------------------------

# Seurat setup (note: not using celltype_posthoc here)
DefaultAssay(object = dat) <- 'RNA'
Idents(object = dat) <- 'seurat_clusters'

# Extract data
lr_data <- FetchData(object = dat, vars = c('seurat_clusters','orig.ident', lr_genes), slot = 'data')

# Calculate average expression + percent expression matrices per cell/orig.ident
exp_avg <- lr_data %>%
  group_by(seurat_clusters, orig.ident) %>%
  summarise_at(.vars = lr_genes, .funs = mean)
exp_pct <- lr_data %>%
  group_by(seurat_clusters, orig.ident) %>%
  summarise_at(.vars = lr_genes, .funs = function(x) round(mean(x > 0), 3))

# Table of cell counts per orig.ident. Needed for cell permutation sample sizes
cell_counts <- table(dat$seurat_clusters, dat$orig.ident)

# Cell-level expression matrix for genes in LR reference
exp_mat <- as.matrix(FetchData(dat, vars = lr_genes, slot = 'data'))
exp_mat_ligands <- exp_mat[,match(lr_ref[['Ligand.ApprovedSymbol']], colnames(exp_mat))]
exp_mat_receptors <- exp_mat[,match(lr_ref[['Receptor.ApprovedSymbol']], colnames(exp_mat))]

# Determine # of permutations
resample <- 1000

# Data structure for holding results and null distribution score values
var_set <- expand.grid(levels(lr_data$seurat_clusters), levels(lr_data$seurat_clusters), levels(lr_data$orig.ident))
colnames(var_set) <- c('Ligand_cell','Receptor_cell','orig.ident')

maxT_scores <- matrix(0, nrow = resample, ncol = nrow(lr_ref))
# maxT_scores <- vector(mode = 'list', length = nrow(var_set))
colnames(maxT_scores) <- paste(colnames(exp_mat_ligands), colnames(exp_mat_receptors), sep = '_')
# names(maxT_scores) <- paste(var_set$Ligand_cell, var_set$Receptor_cell, var_set$orig.ident, sep = '_')


# calculate null distribution of max-T values
for(i in 1:nrow(var_set)) {
  cellx <- as.character(var_set$Ligand_cell[i]) # these are factors, but cell_counts is sorted by level
  celly <- as.character(var_set$Receptor_cell[i])
  orig.identz <- as.character(var_set$orig.ident[i])
  countx <- cell_counts[cellx, orig.identz]
  county <- cell_counts[celly, orig.identz]
  if(countx == 0 | county == 0) {
    next()
  }
  
   # Randomly select n_c cells (n = #, c = cell-type) 1000 times and extract element positions
  cell_sample <- function(x) {tmp <- rep(0, nrow(exp_mat)); tmp[sample(nrow(exp_mat), size = x, replace = FALSE)] <- 1; return(tmp)}
  index_x <- t(replicate(n = resample, expr = cell_sample(countx)))
  index_y <- t(replicate(n = resample, expr = cell_sample(county)))
  
  # Calculate average expression of all ligands and receptors for the n_c cells
  t <- Sys.time()
  avg_lig <- index_x %*% exp_mat_ligands / countx
  avg_rec <- index_y %*% exp_mat_receptors / county
  print(Sys.time() - t)
  
  # Calculate null LR scores
  scores <- 1/2 * (avg_lig + avg_rec)
  colnames(scores) <- paste(colnames(avg_lig), colnames(avg_rec), sep = '_')
  
  # For max-T method, take element-wise maximum values (this iterates nrow(var_set) times)
  maxT_scores[scores > maxT_scores] <- scores[scores > maxT_scores]
  # maxT_scores[[i]] <- scores
  print(paste("done with", i))
  # print(mean(maxT_scores[,1]))
}

# Calculate average expression matrix
exp_avg <- lr_data %>%
  group_by(seurat_clusters, orig.ident) %>%
  summarise_at(.vars = lr_genes, .funs = mean)
exp_names <- paste(exp_avg[['seurat_clusters']], exp_avg[['orig.ident']], sep = '_')
exp_avg <- exp_avg[,3:ncol(exp_avg)]

# Get indices from expression matrix for ligands/receptors
index_x <- paste(var_set[['Ligand_cell']], var_set[['orig.ident']], sep = '_')
index_x <- match(x = index_x, table = exp_names)
index_y <- paste(var_set[['Receptor_cell']], var_set[['orig.ident']], sep = '_')
index_y <- match(x = index_y, table = exp_names)
index_l <- match(lr_ref[['Ligand.ApprovedSymbol']], colnames(exp_avg))
index_r <- match(lr_ref[['Receptor.ApprovedSymbol']], colnames(exp_avg))
exp_avg_lig <- as.matrix(exp_avg[index_x, index_l])
exp_avg_rec <- as.matrix(exp_avg[index_y, index_r])

# Sanity check - do all column LR pairs match for null maxT matrix and actual expression matrix?
sanity.check <- paste("Do all column LR pairs match?", all(paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_') == colnames(maxT_scores)))
print(sanity.check)

# Calculate LR scores (for data, not nulls)
exp_scores <- 1/2 * (exp_avg_lig + exp_avg_rec)

# Determine which cells do not have at least 10% expression of their gene
exp_pct_filter <- exp_pct[,3:ncol(exp_pct)]
exp_pct_filter_l <- exp_pct_filter[index_x, index_l] < 0.1
exp_pct_filter_r <- exp_pct_filter[index_y, index_r] < 0.1
exp_pct_filter_both <- exp_pct_filter_l | exp_pct_filter_r

# Replace values that don't meet 10% threshold
exp_scores[exp_pct_filter_both] <- NA
rownames(exp_scores) <- paste(var_set[[1]], var_set[[2]], var_set[[3]], sep = '_')
colnames(exp_scores) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')

# Dims of exp_scores are <(cellx * celly * orig.identz), (lig-rec pair)>
# Dims of maxT_scores are <(resampled permutations), (lig-rec pair)>

# Calculate p-values from ecdf using null scores for each LR-pair
pvals <- matrix(NA, nrow = nrow(var_set), ncol = nrow(lr_ref))

# # For maxT:
# # Calculate p-values from ecdf using null scores for each LR-pair
pvals <- matrix(1, nrow = nrow(var_set), ncol = nrow(lr_ref))
for(i in 1:ncol(pvals)) {
  pvals[,i] <- sapply(X = exp_scores[,i],
                      nulls = maxT_scores[,i],
                      FUN = function(x, nulls) {1-ecdf(nulls)(x)})
}
colnames(pvals) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')
rownames(pvals) <- paste(var_set[[1]], var_set[[2]], var_set[[3]], sep = '_')

# # For not maxT:
# for(i in 1:nrow(pvals)) {
#   tmp_nulls <- maxT_scores[[i]]
#   tmp_scores <- exp_scores[i,]
#   for(j in 1:length(tmp_scores)) {
#     if(is.null(tmp_nulls)) {
#       next()
#     } else {
#       pvals[i,j] <- 1-ecdf(tmp_nulls[,j])(tmp_scores[j])
#     }
#   }
# }
# colnames(pvals) <- paste(colnames(exp_avg_lig), colnames(exp_avg_rec), sep = '_')
# rownames(pvals) <- paste(var_set[[1]], var_set[[2]], var_set[[3]], sep = '_')

cell_prop <- round(prop.table(cell_counts, margin = 1), 3)*100

# Long-form data.table of results
tmp <- expand.grid(rownames(exp_scores), colnames(exp_scores), stringsAsFactors = FALSE)
tmp_idents <- strsplit(x = tmp[[1]], split = '_')
tmp_pairs <- strsplit(x = tmp[[2]], split = '_')
ligand_cell <- sapply(X = tmp_idents, FUN = `[[`, 1)
receptor_cell <- sapply(X = tmp_idents, FUN = `[[`, 2)
orig.ident <- sapply(X = tmp_idents, FUN = `[[`, 3)
ligand <- sapply(X = tmp_pairs, FUN = `[[`, 1)
receptor <- sapply(X = tmp_pairs, FUN = `[[`, 2)
cell_pair <- paste(ligand_cell, receptor_cell, sep = '_')
lr_pair <- paste(ligand, receptor, sep = '_')
tmp_scores <- exp_scores %>% reshape2::melt() %>% .[[3]]
tmp_avg_l <- c(exp_avg_lig)
tmp_avg_r <- c(exp_avg_rec)
tmp_pvals <- pvals %>% reshape2::melt() %>% .[[3]]
tmp_pct <- exp_pct_filter %>% as.matrix()
tmp_pct_l <- c(tmp_pct[index_x, index_l])
tmp_pct_r <- c(tmp_pct[index_y, index_r])
tmp_count_l <- mapply(FUN = function(x,y) cell_prop[x,y], ligand_cell, orig.ident)
tmp_count_r <- mapply(FUN = function(x,y) cell_prop[x,y], receptor_cell, orig.ident)

# Final result compilation
results <- data.frame('Ligand_cell' = ligand_cell,
                      'Receptor_cell' = receptor_cell,
                      'orig.ident' = orig.ident,
                      'Ligand' = ligand,
                      'Receptor' = receptor,
                      'Score' = tmp_scores,
                      'p_value' = tmp_pvals,
                      'Ligand_avgExp' = tmp_avg_l,
                      'Receptor_avgExp' = tmp_avg_r,
                      'Ligand_pct' = tmp_pct_l,
                      'Receptor_pct' = tmp_pct_r,
                      'Cell_pair' = cell_pair,
                      'LR_pair' = lr_pair,
                      'Ligand_cell_pct' = tmp_count_l,
                      'Receptor_cell_pct' = tmp_count_r,
                      stringsAsFactors = FALSE)

# Save results
saveRDS(object = results, file = paste0(results_outpath, 'LR_results_SVZ_pValAdj.rds'))
write.csv(x = results, file = paste0(results_outpath, 'LigandReceptorAnalysis_pValAdj.csv'))
```


```{r}
lr_results <- readRDS(file = paste0(results_outpath, 'LR_results_SVZ_pValAdj.rds'))
lr_results %>%
  group_by(Receptor_cell) %>%
  filter(p_value < 0.05) %>%
  
```



```{r sessionInfo, results='hide'}
saveRDS(dat, file = paste0(results_outpath, '20200511_SVZ.rds'))
sessionInfo()
```